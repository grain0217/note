## 模块机制

#### CommonJS module
CommonJS规范规定，每个模块内部，`module`变量代表当前模块。这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。加载某个模块，其实是加载该模块的`module.exports`属性。

CommonJS规范特点如下：

1.所有代码都运行在模块作用域内，不会污染全局作用域。
2.模块可以多次加载，但是只会**在第一次加载时运行一次**，然后模块就被缓存了，以后再加载，就直接读取缓存结果。如果要让模块再次运行，必须清除缓存。
3.模块加载的顺序，按照其在代码中出现的顺序。
4.模块加载是同步的，只有模块加载完成，才能执行后面的操作。

Node内部提供一个Module构建函数。所有模块都是Module的实例。

- `module.id`
模块的识别符，通常是带有绝对路径的模块文件名。
- `module.filename`
模块的文件名，带有绝对路径
- `module.loaded`
返回一个布尔值，表示模块是否已经完成加载
- `module.parent`
返回一个对象，表示调用该模块的模块
- `module.children`
返回一个数组，表示该模块要用到的其他模块
- `module.exports`
表示模块对外输出的值

为了方便，Node为每个模块提供一个exports变量，指向module.exports，这等同于在每个模块的头部有一行这样的命令：
```javascript
var exports = module.exports
```
因此，在对外暴露模块接口时可以通过向exports对象添加属性方法：
```javascript
exports.area = function (r) {
  return Math.PI * r * r
}

exports.circumference = function (r) {
  return 2 * Math.PI * r
}
```
需要注意的是，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系：
```javascript
exports = function(x) {
  return x * x
}
```
#### AMD规范
由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，加载较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是对于浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，浏览器端一般采用AMD规范。

requireJS是AMD规范的一种实现，它主要解决两个问题：
- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，在前面的模块都加载成功后才会运行，解决了依赖性的问题
#### CMD规范
CMD是在AMD基础上改进的一种规范，和AMD的不同在于对依赖模块的**执行时机**处理不同

```javascript
// CMD 
define(function(require, exports, module) {
  var a = require('./a')
  a.doSomething()
  var b = require('./b') // 依赖就近书写
  b.doSomething()
})
```
CMD 推崇依赖就近，而 AMD 推崇依赖前置：
```javascript
// AMD
define(['./a', './b'], function(a, b) { 
  // 依赖必须一开始就写好
  a.doSomething()
  b.doSomething()
})
```
#### ES 6 模块
ES6标准发布后，module成为标准，标准使用是以`export`指令导出接口，以`import`引入模块，但是在我们一贯的node模块中，我们依然采用的是`CommonJS规范`，使用`require`引入模块，使用`module.exports`导出接口

在ES 6标准中，
`export`只支持对象形式的导出，不支持值的导出
`export default`命令用于指定模块的默认输出，只支持值导出，但是只能指定一个

- `import` 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。
- `export` 命令会有变量声明提前的效果。