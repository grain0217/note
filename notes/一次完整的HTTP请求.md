### 在浏览器中输入http:www.stackoverflow.com后会发生什么？

- DNS解析：由域名得到IP地址

  先**递归查询**，按照

	>浏览器缓存->操作系统缓存->操作系统hosts文件->路由器缓存

  的顺序去查询域名缓存，若没有找到则向本地DNS服务器（一般DNS服务器在计算机接入网络时由ISP自动分配）发送请求查询。
 若在本地DNS服务器中也找不到，则向根域名服务器发送请求，按照
 
	>根DNS服务器->顶级DNS服务器->权威DNS服务器

  的顺序**迭代查询**。
  
  不同于下面的HTTP请求，DNS请求是基于UDP协议的（如果响应包太大会使用TCP），因此发送DNS请求需要构造UDP请求报文：目的端口号为53，源端口号为1024-65535中的一个整数，UDP报文的传输在网络层仍然是基于IP协议的，不需要三次握手建立连接。
- 封装TCP报文段

  当客户端通过DNS请求或者本地缓存拿到IP地址之后，先构造HTTP请求。HTTP请求头部包含Cookie、User-Agent、Accept-Language等信息，请求体包含请求参数等信息。这个请求首先被添加目标端口（HTTP为80,HTTPS为443）、源端口（操作系统动态选取1024-65535中的一个整数）等信息作为TCP报文段头部，封装成一个TCP报文段，交给传输层。
- 封装IP数据报

  TCP报文段被加上IP头（里面包含目标IP地址及本机IP地址等信息）封装成IP数据报送入网络层。
- 以太网数据包

  通过子网掩码，判断本机IP与目的IP是否在同一个子网中，如果在同一个子网中可通过ARP广播查询到目的MAC；如果不在，则之后的请求要通过网关转发（即接收方MAC地址字段为网关的MAC地址，而网关的MAC地址通过ARP广播得到）。
得到目的MAC地址，封装成帧在以太网中传输。
以太网数据包的数据部分最大长度为1500字节，如果IP数据报长度超过1500，则将对IP数据报进行分包。
- 路由寻址

  IP路由选择是逐跳进行的，所有的IP选择只为数据包提供下一跳的IP地址。IP数据报头部TTL域的值每经过一个路由器就减1，如果IP数据报头部的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。
路由选择的基础是在每一台主机和路由器中都存储着一张路由表，路由表包含以下信息：

	>目的主机IP地址
	>下一跳路由器/主机IP
	>相应的网络接口

	- 如果目的IP与本机IP在同一个网络内，则直接发送；	
	- 若不是则查询路由表，找到一个路由，交给下一跳路由器；
	- 找不到明确的路由，此时路由表（路由表的建立依赖于路由算法）中有默认网关，IP数据报转发往默认网关（路由器）；
	- 路由器收到数据后，它再次查询路由表，找到则转发；否则转发往默认网关（另一个路由器），当TTL减为0时不再转发。
- 通过三次握手建立连接

  每一条TCP连接的建立都需要三次握手：

	>客户端发送SYN标志的数据包请求连接
	>服务端收到SYN请求后，如果被请求的端口正在等待连接，则为这一条TCP连接请求分配资源，并发送一个SYN/ACK报文段作为应答
	>客户端接收到SYN/ACK报文段后，回传给服务端一个ACK数据包，此时握手结束。HTTP报文段在第三次握手时发送
- 服务器响应

  服务器端响应，返回HTML文档至客户端。
- 浏览器解析渲染

  边下载边解析：

    >解析HTML文档，构建DOM树
    
    >解析HTML文档碰到JavaScript、CSS脚本时，再次发送HTTP请求，但是浏览器对于同一个域名下资源请求有并发限制
    
    >解析CSS，构建CSSOM
    
    >构建渲染树(Render Tree)，渲染树不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了
    
    >布局（layout）：根据渲染树计算节点在显示设备上的准确位置和尺寸
    
    >绘制（paint）：调用操作系统Native GUI的API绘制每一个像素点
    
    >JavaScript脚本的执行，有可能（即通过DOM和CSSOM的API来操作DOM树和CSS规则树）引起**回流和重绘**
    
    >重绘（Repaint）：屏幕的一部分要重画，比如某个CSS的背景色变了，但是元素的几何尺寸和位置没有变
    
    >回流（reflow）：节点的几何尺寸或位置改变，渲染树的一部分重新渲染->布局->绘制

  呈现页面。
- 客户端关闭连接，TCP四次挥手

  一般情况下，在HTTP请求报文段头部中有这样一个字段：

	>Connection:keep-alive
	
   客户端会与服务端保持一段时间的TCP连接，以备浏览器在解析HTML文档中的脚本后往服务端继续发送HTTP请求的TCP开销（复用这条连接）或者是一个HTTP请求过长分包仍要使用这条TCP连接。在客户端一段时间后没有请求发往服务器端后，服务器端关闭连接。
如果HTTP请求报文段头部中这个字段的值是**close**的话，这条TCP连接会马上关闭：

    >客户端向服务端发出FIN报文段
    
    >服务端收到FIN，回复ACK报文段给客户端
    
    >服务端在所有需要处理的请求完成后，向客户端发送FIN报文段，并释放资源 
    
    >客户端收到FIN后，回复ACK，一段时间后客户端释放资源
