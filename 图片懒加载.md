## 传统处理方式
图片懒加载是指在长网页中，在用户将图片滚动到可视区域内时再去加载它们。
大概思路：
1. 将图片的src属性置空，真实资源路径放到图片标签的其他属性（或变量）中
2. 监听页面滚动，当图片出现在可视区域内，用真实资源路径重写图片的src属性

#### 1. src属性置空
```html
<img class="lazy-img" src="" data-src="http://demo.img">
```

#### 2. 监听页面滚动，判断图片是否进入可视区域
```js
// 使用节流优化事件处理
import throttle from 'debounce'

function watchScroll () {
  const viewHeight = window.innerHeight || document.documentElement.clientHeight
  const imgs = document.querySelectorAll('.lazy-img')
  const _imgs = Array.from(imgs)
  _imgs.forEach(i => {
    const imgTop = i.getBoundingClientRect().top
    if (imgTop < viewHeight ) {
      i.src = i.getAttribute('data-src')
      i.classList.remove('lazy-img')
    }
  })
}
document.addEventListener('scroll', throttle(watchScroll, 200))
```

## 交叉观察者 IntersectionObserver
故事本来到这里可以结束了，但是对scroll事件的监听（即便使用了节流仍然会）导致大量计算，以及`setTimeout`的使用仍然存在性能问题。

在2016年，chrome中实现了一个新的API —— `IntersectionObserver`，它的任务就是监听目标元素与指定父元素（用户可指定，**默认为viewport**）是否在发生交叉行为，简单理解就是监听目标元素是否进入或者离开了指定父元素的内部。

使用：
```js
const observer = new IntersectionObserver(callback, options) 
```
其中`callback`代表当被监听的元素可见性发生变化时触发的回调函数， `callback`接收一个`entries`参数，表示当前已监听并且发生了交叉的目标集合，集合中的对象`IntersectionObserverEntry`长这个样子：
```json
{
  "boundingClientRect": Client {},
  "intersectionRatio": 0.02465277723968029,
  "time": 2342.614999972284,
  "rootBounds": ClientRect {
    "bottom": 1051.125,
    "height": 1051.125,
    "left": 0,
    "right": 1342.234375,
    "top": 0,
    "width": 1342.234375,
    "x": 0,
    "y": 0,
  },
  "intersectionRect": Client {},
  "target": <img src="" data-src="...">,
  "isVisible": false,
  "isIntersecting": true
}
```

- target: 被观察的目标元素，是一个DOM节点对象
- time: 可见性发生变化的时间
- rootBounds: 根元素的矩形区域信息
- boundingClientRect: 目标元素的矩形区域信息
- intersectionRect: 目标元素与视口的交叉区域信息
- intersectionRatio: 目标元素的可见比例，intersectionRect/boundingClientRect
- 猫眼

构造函数返回一个构造器实例，通过实例的`observe`方法来指定需要观察的DOM节点：
```js
// 开始观察
observer.observe(img)

// 停止观察
observer.unobserver(img)

// 关闭观察器
observer.disconnect()
```

回归需求：
```js
const observer = new IntersectionObserver(function (changes) {
  changes.forEach(function (change) {
    const target = change.target
    if (!target.src) {
      target.src = target.getAttribute('data-src')
    }
  })
}, null)

const imgs = Array.from(document.querySelectorAll('.lazy-img'))
imgs.forEach(img => observer.observe(img))
```