图片懒加载是指在长网页中，在用户将图片滚动到可视区域内时再去加载它们。
大概思路：
1. 将图片的src属性置空，真实资源路径放到图片标签的其他属性（或变量）中
2. 监听页面滚动，当图片出现在可视区域内，用真实资源路径重写图片的src属性

#### src属性置空
```html
<img class="lazy-img" src="" data-src="http://demo.img">
```

#### 监听页面滚动，判断图片是否进入可视区域
```js
import debounce from 'debounce'

function watchScroll () {
  const viewHeight = window.innerHeight || document.documentElement.clientHeight
  const imgs = document.querySelectorAll('.lazy-img')
  const _imgs = Array.from(imgs)
  _imgs.forEach(i => {
    const imgTop = i.getBoundingClientRect().top
    if (imgTop < viewHeight ) {
      i.src = i.getAttribute('data-src')
      i.classList.remove('lazy-img')
    }
  })
}
document.addEventListener('scroll', debounce(watchScroll, 200))
```

#### 拓展 IntersectionObserver
故事本来到这里可以结束了，但是对scroll事件的监听（即使使用了防抖或节流仍会）导致大量计算，以及`setTimeout`的使用仍然存在性能问题，2016年初chrome率先实现了一个新的API —— `IntersectionObserver`（目前在IE、Opera上还不被支持）），用来监听元素是否进入设备的可视区。

使用：
```js
const observer = new IntersectionObserver(callback, options) 
```
其中`callback`代表当被监听的元素可见性发生变化时触发的回调函数， `callback`接收的参数是一个数组，数组中的每一个元素都代表一个[`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)对象：
```json
{
  time: 2342.614999972284,
  rootBounds: ClientRect {
    bottom: 1051.125
    height: 1051.125
    left: 0
    right: 1342.234375
    top: 0
    width: 1342.234375
    x: 0
    y: 0
  },
  boundingClientRect: Client {},
  intersectionRect: Client {},
  intersectionRatio: 0.02465277723968029,
  target: <img src="" data-src="...">
}
```
- target: 被观察的目标元素，是一个DOM节点对象
- time: 可见性发生变化的时间
- rootBounds: 根元素的矩形区域信息
- boundingClientRect: 目标元素的矩形区域信息
- intersectionRect: 目标元素与视口的交叉区域信息
- intersectionRatio: 目标元素的可见比例，intersectionRect/boundingClientRect


构造函数返回一个构造器实例，通过实例的`observe`方法来指定需要观察的DOM节点：
```js
// 开始观察
observer.observe(img)

// 停止观察
observer.unobserver(img)

// 关闭观察器
observer.disconnect()
```

回归需求：
```js
const observer = new IntersectionObserver(function (changes) {
  changes.forEach(function (change) {
    const target = change.target
    if (!target.src) {
      target.src = target.getAttribute('data-src')
    }
  })
}, null)

const imgs = Array.from(document.querySelectorAll('.lazy-img'))
imgs.forEach(img => observer.observe(img))
```