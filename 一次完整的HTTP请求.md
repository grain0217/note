以下按照时间先后顺序描述在浏览器中输入`http:www.baidu.com`后发生的事情：

### 1. DNS解析
`DNS`解析是指由域名得到`IP`地址，依次按照下面的顺序去查询域名缓存：
```
浏览器缓存 -> 操作系统缓存 -> 操作系统hosts文件 -> 路由器缓存
```

若没有找到则向本地`DNS`服务器发送请求查询，本地`DNS`服务器一般在计算机接入网络时由`ISP`即互联网服务商(如电信、联通、长城宽带等)自动分配。

若在本地`DNS`服务器中也找不到域名，则继续向根域名服务器发送请求，按照下面的顺序查询：
```
根DNS服务器 -> 顶级DNS服务器 -> 权威DNS服务器
```

与`HTTP`协议一样，`DNS`也是应用层协议，但`DNS`协议在传输层是基于`UDP`协议的（如果响应包太大也会使用TCP），**不需要三次握手建立连接**，发送`DNS`请求需要构造`UDP`请求报文：目的端口号为`53`，源端口号为`1024-65535`中的一个整数。

### 2. 建立连接（IP、TCP、物理主机）
- 封装`TCP`报文段

  当客户端通过DNS请求或者本地缓存拿到IP地址之后，先构造HTTP请求。HTTP请求头部包含Cookie、User-Agent、Accept-Language等信息，请求体包含请求参数等信息。这个请求首先被添加目标端口（HTTP为80,HTTPS为443）、源端口（操作系统动态选取1024-65535中的一个整数）等信息作为TCP报文段头部，封装成一个TCP报文段，交给传输层。
- 封装IP数据报

  `TCP`报文段被加上`IP`头（里面包含目标`IP`地址及本机`IP`地址等信息）封装成**IP数据报**送入网络层。
- 以太网数据包

  通过子网掩码，判断本机IP与目的IP是否在同一个子网中，如果在同一个子网中可通过ARP广播查询到目的MAC；如果不在，则之后的请求要通过网关转发（即接收方MAC地址字段为网关的MAC地址，而网关的MAC地址通过ARP广播得到）。
得到目的MAC地址，封装成帧在以太网中传输。
以太网数据包的数据部分最大长度为1500字节，如果IP数据报长度超过1500，则将对IP数据报进行分包。
- 路由寻址

  IP路由选择是逐跳进行的，所有的IP选择只为数据包提供下一跳的IP地址。IP数据报头部TTL域的值每经过一个路由器就减1，如果IP数据报头部的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。
路由选择的基础是在每一台主机和路由器中都存储着一张路由表，路由表包含以下信息：

	>目的主机IP地址
	>下一跳路由器/主机IP
	>相应的网络接口

	- 如果目的IP与本机IP在同一个网络内，则直接发送；	
	- 若不是则查询路由表，找到一个路由，交给下一跳路由器；
	- 找不到明确的路由，此时路由表（路由表的建立依赖于路由算法）中有默认网关，IP数据报转发往默认网关（路由器）；
	- 路由器收到数据后，它再次查询路由表，找到则转发；否则转发往默认网关（另一个路由器），当TTL减为0时不再转发。
- 通过三次握手建立连接

  每一条`TCP`连接的建立都需要三次握手：

	>客户端发送SYN标志的数据包请求连接
	>服务端收到SYN请求后，如果被请求的端口正在等待连接，则为这一条TCP连接请求分配资源，并发送一个SYN/ACK报文段作为应答
	>客户端接收到SYN/ACK报文段后，回传给服务端一个ACK数据包，此时握手结束。HTTP报文段在第三次握手时发送

### 3. 服务器的处理
负载均衡？ARP？Nginx

服务器端响应，静态资源或者或其他类型数据给客户端

### 4. 浏览器解析渲染
客户端边下载边解析`HTML`文档：
1. 解析HTML文档，构建DOM树
  
2. 解析HTML文档碰到JavaScript、CSS脚本时，再次发送HTTP请求，但是浏览器对于同一个域名下资源请求有并发限制
    
3. 解析CSS，构建CSSOM
    
4. 构建渲染树(Render Tree)，渲染树不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了
    
5. 布局（layout）：根据渲染树计算节点在显示设备上的准确位置和尺寸
    
6. 绘制（paint）：调用操作系统Native GUI的API绘制每一个像素点
    
7. JavaScript脚本的执行，有可能（即通过DOM和CSSOM的API来操作DOM树和CSS规则树）引起**回流和重绘**
    
8. 重绘（Repaint）：屏幕的一部分要重画，比如某个CSS的背景色变了，但是元素的几何尺寸和位置没有变
    
9. 回流（reflow）：当节点的几何尺寸或位置改变时，渲染树的一部分再次进入 `渲染->布局->绘制` 的流程

10. 呈现页面。

### 5. 关闭TCP连接
一般情况下，在`HTTP(1.1)`请求报文段头部中有这样一个字段：
```http
Connection: keep-alive
```
	
客户端会与服务端保持一段时间的`TCP`连接，以避免浏览器在解析到`HTML`文档中的其他静态资源后继续向服务端发送`HTTP`请求或者是一个`HTTP`请求过长分包仍要使用这条`TCP`连接而造成的重复开销（即可以复用这条连接）。在客户端一段时间后没有请求发往服务器端，服务器端关闭连接。

而如果`HTTP`请求报文段头部中这个字段的值是**close**的话
```http
Connection: close
```

这条`TCP`连接会马上关闭。

`TPC`连接关闭的过程：
1. 客户端向服务端发出`FIN`报文段
  
2. 服务端收到`FIN`，回复`ACK`报文段给客户端
  
3. 服务端在所有需要处理的请求完成后，向客户端发送`FIN`报文段，并释放维持`TCP`连接资源 
  
4. 客户端收到`FIN`后，回复`ACK`，一段时间后客户端释放资源

### 补充
1. 建立TCP连接为什么需要三次握手？
在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。
谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接”。

所以三次握手的主要目的防止server端一直等待，浪费资源。

2. 关闭TCP连接为什么需要四次挥手？

