## 什么是模块化
1. 将一个复杂的程序依据一定的规则、规范封装成几个文件，并进行组合
2. 模块的内部的数据与实现是私有的，对外暴露一些方法及属性与其他模块通信

## 模块化的发展进化进程
#### 1. 函数封装
将不同的功能封装成不同的全局函数，
```js
function foo () {}
function bar () {}
```
不足： 污染全局命名空间，容易引起命名冲突

#### 2. 命名空间
简单对象封装：
```js
const Module = {
  data: 'data in module',
  foo () {
    console.log(`foo: ${this.data}`)
  }
}
```
不足： 数据不安全，外部可以直接修改内部数据
```js
Module.data  = 'other data'
```
从外部修改了模块内数据

#### 3. IIFE匿名函数自调用
```js
(function (window) {
  let data = 'data in module'
  function foo () {
    console.log(`foo: ${data}`)
  }
  function bar () {
    console.log(`bar: ${data}`)
    innerFun()
  }
  function innerFun () {
    console.log('inner function')
  }
  window.Module = { foo, bar }
})(window)

Module.foo()
Module.bar()
console.log(Module.data) // undefined
Module.data = 'out data'
Module.foo() // 不受影响，仍然输出 'foo: data in module'
```
将数据和行为封装到函数内部，并通过为window添加属性向外部暴露方法

优点：模块内部数据是私有的，外部只能通过该模块内指定暴露的 方法/属性 访问模块

如果当前模块依赖其他模块，如何解决？

#### 4. IIFE增强——引入依赖
```js
(function (window, $) {
  let data = 'data in module'
  function foo () {
    console.log(`foo: ${data}`)
    $('body').css('background', 'blue')
  }
  function bar () {
    console.log(`bar: ${data}`)
    innerFun()
  }
  function innerFun () {
    console.log('inner function')
  }
  window.Module = { foo, bar }
})(window, jQuery)

Module.foo()
```

当前模块依赖jQuery库，因此需要将jQuery作为参数传入，这样**保证了模块之间的独立性，模块间的依赖关系也表现地比较明显**，这就是模块模式，也是现代模块实现的基石。

## 模块化的好处
- 避免命名冲突、减少命名空间污染
- 按需加载
- 复用性、维护性
- ...

## 模块化规范
传统的通过`<script>`引入模块的方式，存在两个问题：一是每个JavaScript模块对应一个资源请求，当引入多个模块时会导致请求过多；二是模块间的依赖关系，导致严格的`<script>`的先后顺序，且依赖关系模块。

针对上面的问题，各种前端模块化规范也应用而生了，下面对各个规范作介绍。
- CommonJS
- AMD
- CMD
- ES Module

---
## CommonJS
Nodejs环境所使用的模块系统就是基于CommonJs规范实现的，我们现在所说的CommonJs规范也大多是指Node的模块系统。

CommonJS规范规定，每个模块内部，`module`变量代表当前模块。这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。加载某个模块，其实是加载该模块的`module.exports`属性。

CommonJS规范特点如下：

1. 所有代码都运行在模块作用域内，不会污染全局作用域。
2. 模块可以多次加载，但是只会在第一次加载时**运行**一次，然后模块就被缓存了，以后再加载，就直接读取缓存结果。如果要让模块再次运行，必须清除缓存。
3. 模块加载的顺序，按照其在代码中出现的顺序。
4. 模块加载是**同步**的，只有模块加载完成，才能执行后面的操作。

Node内部提供一个Module构造函数，所有模块都是Module的实例。

- `module.id`
模块的识别符，通常是带有绝对路径的模块文件名。
- `module.filename`
模块的文件名，带有绝对路径
- `module.loaded`
返回一个布尔值，表示模块是否已经完成加载
- `module.parent`
返回一个对象，表示调用该模块的模块
- `module.children`
返回一个数组，表示该模块要用到的其他模块
- `module.exports`
表示模块对外输出的值

#### 1. 模块导出
`module.exports`表示当前模块对外暴露的接口，其他模块加载当前模块实际上就是读取`module.exports`变量。为了方便，Node为每个模块提供一个`exports`变量，指向`module.exports`，这等同于在每个模块的头部有一行这样的命令：

```js
var exports = module.exports
```

因此，在对外暴露模块接口时可以通过向`exports`对象添加属性方法：

```js
// 单个导出
exports.area = function (r) {
  return Math.PI * r * r
}

module.exports.hi = function () {}

// 整体导出
module.exports = {
  name: 'hello',
  foo: function () {}
}
```

需要注意的是，不能直接将`exports`变量重新赋值，因为这样等于切断了`exports`与`module.exports`的联系：

```js
exports.area = function () {}

// 下面的模块定义无效
exports = function(x) {
  return x * x
}
```

#### 2. 模块导入
`require`命令用于加载模块，模块后缀名默认为`.js`。

根据参数格式的不同，`require`命令会去不同的路径去寻找模块。
  1. 绝对路径，如`require('/home/marco/foo')`，表示加载的是一个位于绝对路径的模块文件

  2. 相对路径，如`require('./foo')`表示加载一个位于相对路径（与当前模块位置相比）的模块文件。举例来说，模块`grain/index`内执行`require('./foo')`，Node会依次搜索以下文件：
      - /grain/foo.js | foo.json | foo.node
      - /grain/foo/package.json文件中main字段指定的文件
      - /grain/foo/index.js | index.json | index.node

  3. 参数字符串不包含`./`或`/`，参数字符串为模块名，则表示加载的是一个默认提供的核心模块（位于操作系统Node的安装目录中），或者是一个位于各级node_module目录中已经安装的模块（全局安装或局部安装）。举例来说，模块`home/user/grain/foo.js`内执行了`require('bar.js')`命令，Node会依次搜索以下文件：
      - /usr/local/bin/node/bar.js
      - /home/user/grain/node_modules/foo.js
      - /home/user/node_modules/bar.js
      - /node_modules/bar.js

  3. 参数字符串不以`./`或`/`开头，但是仍是一个路径，比如`require('demo/path/to/file')`，则Node会先找到`demo`的位置，然后再以它为参数找到后续路径。

  5. 不指定模块文件后缀名，Node会尝试依次按照为模块添加`.js`
  、`.json`、`.node`寻找

  6. 使用`require.resolve()`方法可以得到`requrie`命令加载的模块的确切文件名

#### 3. 目录的加载规则
通常我们把相关的模块放在同一个目录下，这时可以为目录设置一个入口文件以便`require`方法可以通过这个入口文件加载整个目录。方法是在目录中放一个`package.json`文件，将入口文件写入`main`字段：

```json
{
  "name": "myLib",
  "main": ""
}
```

`require`方法解析到参数字符串指向一个目录后，会自动查看目录中的`package.json`文件记载`main`字段指定的入口文件，如果没有`main`字段或者没有`package.json`文件，则会加载目录下的`index.js`、`index.json`、`index.node`。

#### 4. 模块的缓存
第一次加载模块时，Node会缓存模块。之后再次加载，直接从缓存中读取该模块的`module.exports`属性。

```js
require('./demo.js')
require('./demo.js').message = 'demo'
require('./demo.js').message
// demo
```

可以看到，在第二次加载模块时为对象添加了`message`属性，第三次加载时`message`依然存在，这说明`requrie`命令并没有重新加载模块而是输出了缓存。

需要注意的是，缓存是根据缓存路径识别模块的，如果同样的文件名保存在不同的路径上，`require`命令还是会重新加载模块的。

#### 5. 模块的循环加载

___
## AMD 和 CMD
由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，加载较快，不用考虑非同步加载的方式，所以对Node.js来讲CommonJS规范比较适用。但对于浏览器环境，要从服务器端加载模块，就必须采用异步模式。

伴随着`ES Module`的出现，AMD和CMD逐渐被淘汰，下面仅对曾经流行的AMD和CMD做简单介绍。

AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

CMD是另一种JavaScript模块化方案，它与AMD类似，不同之处在于——AMD推崇依赖前置、提前执行，而CMD推崇依赖就近、延迟执行。

AMD是`RequireJS`在推广过程中对模块定义的规范化产出, CMD是`SeaJS`在推广过程中对模块定义的规范化产出。

```js
// AMD
// 定义模块
// count-down.js
define('coun-down', ['jquery'], function($) { 
  // 依赖必须一开始就写好
  $('#app').html('test')
  console.log('hahha')
  var foo = function (n) {
    return n + 1
  }
  // 导出模块
  return {
    foo: foo
  }
})

// 加载模块
require(['count-down'], function (f) {
  // 即使加载了cout-down模块不使用，count-down模块内的脚本也会提前执行
  // 在这里先$('#app').html('test')，输出'hahaha'，之后才执行下面的回调
  f.foo(2)
})
```

AMD推崇依赖前置，提前执行。在定义模块的时候就要声明其依赖的模块，加载的模块先于指定回调执行。

```js
// CMD 
define(function(require, exports, module) {
  console.log('定义CMD模块')
  var b = require('count-down') // 依赖就近书写
  
  // 几种导出模块的形式
  // module.exports = {}
  // exports.foo = function () {}
  // return {
  //   foo: function () {}
  // }
})
```

CMD推崇就近依赖，延迟执行。

___
## ES 6模块
ES 6在语言标准的层面上，实现了模块功能，**旨在成为浏览器和服务器通用的模块解决方案**。

ES 6模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。

ES 6模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。

```js
// 加载模块
import { dateFormat, appId } from 'util';

// 导出模块
// util.js
export function dateFormat (time, format) {
  // ...
}

export const appId = 'zxcadasfsazfdsazfasd'
```

上面代码的实质是从`util`模块加载一个方法和一个常量，其他方法、变量不加载。这种加载称为 **“编译时加载”** 或者 **静态加载**，即ES 6可以在编译时就完成模块加载。

ES 6模块自动采用严格模式，因此有以下限制：
1. 变量必须先声明后使用
2. 不能使用`with`
3. 不能对只读属性赋值
4. 不能使用`this`指向全局对象，顶层`this`指向`undefined`
5. 不能使用`arguments.callee`、`arguments.caller`

___
## ES Module和CommonJS模块
1. CommonJS模块输出的是一个值的拷贝，ES 6模块输出的是值的引用
CommonJS模块输出的是`module.exports`这个对象，我们读取的也是这个对象，而不是模块内部某个变量。
也就是说，一旦输出一个值，模块内部的变化就影响不到这个值（引用类型除外）。而对于ES 6模块，由于在JavaScript引擎对脚本做静态分析的时候，遇到模块加载`import`命令就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

2. CommonJS模块是**运行时**加载，ES 6模块是**编译时**输出接口
这是因为CommonJS的加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而ES 6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段生成，使得编译时就能确定模块的依赖关系(“静态优化”)。

___
#### 参考
1. [理解JS模块化](https://xieyufei.com/2017/02/19/JS-Standard.html)
2. [前端模块化详解](https://juejin.im/post/5c17ad756fb9a049ff4e0a62#heading-49)
3. [深入理解ES 6模块机制](https://zhuanlan.zhihu.com/p/33843378?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)