## 什么是模块化
1. 将一个复杂的程序依据一定的规则、规范封装成几个文件，并进行组合
2. 模块的内部的数据与实现是私有的，对外暴露一些方法及属性与其他模块通信

## 模块化的进化进程
#### 函数封装
将不同的功能封装成不同的全局函数，
```js
function foo () {}
function bar () {}
```
不足： 污染全局命名空间，容易引起命名冲突

#### 命名空间
简单对象封装：
```js
const Module = {
  data: 'data in module',
  foo () {
    console.log(`foo: ${this.data}`)
  }
}
```
不足： 数据不安全，外部可以直接修改内部数据
```js
Module.data  = 'other data'
```
从外部修改了模块内数据

#### IIFE匿名函数自调用
```js
(function (window) {
  let data = 'data in module'
  function foo () {
    console.log(`foo: ${data}`)
  }
  function bar () {
    console.log(`bar: ${data}`)
    innerFun()
  }
  function innerFun () {
    console.log('inner function')
  }
  window.Module = { foo, bar }
})(window)

Module.foo()
Module.bar()
console.log(Module.data) // undefined
Module.data = 'out data'
Module.foo() // 不受影响，仍然输出 'foo: data in module'
```
将数据和行为封装到函数内部，并通过为window添加属性向外部暴露方法

优点：模块内部数据是私有的，外部只能通过该模块内指定暴露的 方法/属性 访问模块

如果当前模块依赖其他模块，如何解决？

#### IIFE增强——引入依赖
```js
(function (window, $) {
  let data = 'data in module'
  function foo () {
    console.log(`foo: ${data}`)
    $('body').css('background', 'blue')
  }
  function bar () {
    console.log(`bar: ${data}`)
    innerFun()
  }
  function innerFun () {
    console.log('inner function')
  }
  window.Module = { foo, bar }
})(window, jQuery)

Module.foo()
```

当前模块依赖jQuery库，因此需要将jQuery作为参数传入，这样**保证了模块之间的独立性，模块间的依赖关系也表现地比较明显**，这也是现代模块实现的基石。

## 模块化的好处
- 避免命名冲突、减少命名空间污染
- 按需加载
- 复用性、维护性

## 模块化规范
传统的通过`<script>`引入模块的方式，存在两个问题：一是每个JavaScript模块对应一个资源请求，当引入多个模块时会导致请求过多；二是模块间的依赖关系，导致严格的`<script>`的先后顺序，且依赖关系不明显。

针对上面提到的两点，各种前端模块化规范也应用而生了，下面对各个规范作介绍。
- CommonJS
- AMD
- CMD
- ES 6模块化

----
#### 分割线

----

### CommonJS
CommonJS规范规定，每个模块内部，`module`变量代表当前模块。这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。加载某个模块，其实是加载该模块的`module.exports`属性。

CommonJS规范特点如下：

1. 所有代码都运行在模块作用域内，不会污染全局作用域。
2. 模块可以多次加载，但是只会**在第一次加载时运行一次**，然后模块就被缓存了，以后再加载，就直接读取缓存结果。如果要让模块再次运行，必须清除缓存。
3. 模块加载的顺序，按照其在代码中出现的顺序。
4. 模块加载是同步的，只有模块加载完成，才能执行后面的操作。

Node内部提供一个Module构建函数。所有模块都是Module的实例。

- `module.id`
模块的识别符，通常是带有绝对路径的模块文件名。
- `module.filename`
模块的文件名，带有绝对路径
- `module.loaded`
返回一个布尔值，表示模块是否已经完成加载
- `module.parent`
返回一个对象，表示调用该模块的模块
- `module.children`
返回一个数组，表示该模块要用到的其他模块
- `module.exports`
表示模块对外输出的值

为了方便，Node为每个模块提供一个exports变量，指向module.exports，这等同于在每个模块的头部有一行这样的命令：
```js
var exports = module.exports
```
因此，在对外暴露模块接口时可以通过向exports对象添加属性方法：
```js
exports.area = function (r) {
  return Math.PI * r * r
}

exports.circumference = function (r) {
  return 2 * Math.PI * r
}
```
需要注意的是，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系：
```js
exports = function(x) {
  return x * x
}
```
### AMD
由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，加载较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是对于浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，浏览器端一般采用AMD规范。

requireJS是AMD规范的一种实现，它主要解决两个问题：
- 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
- js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，在前面的模块都加载成功后才会运行，解决了依赖性的问题

### CMD规范
CMD是在AMD基础上改进的一种规范，和AMD的不同在于对依赖模块的**执行时机**处理不同

```js
// CMD 
define(function(require, exports, module) {
  var a = require('./a')
  a.doSomething()
  var b = require('./b') // 依赖就近书写
  b.doSomething()
})
```
CMD 推崇依赖就近，而 AMD 推崇依赖前置：
```js
// AMD
define(['./a', './b'], function(a, b) { 
  // 依赖必须一开始就写好
  a.doSomething()
  b.doSomething()
})
```
### ES 6 模块
ES6标准发布后，module成为标准，标准使用是以`export`指令导出接口，以`import`引入模块，但是在我们一贯的node模块中，我们依然采用的是`CommonJS规范`，使用`require`引入模块，使用`module.exports`导出接口

在ES 6标准中，
`export`只支持对象形式的导出，不支持值的导出
`export default`命令用于指定模块的默认输出，只支持值导出，但是只能指定一个

- `import` 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。
- `export` 命令会有变量声明提前的效果。