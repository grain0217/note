#### 函数防抖
在事件被触发delay时间间隔后再执行回调，如果在这delay时间内又被触发，则重新计时。

```js
function debounce (fn, delay) {
  let timer
  return function () {
    const context = this
    const args = arguments
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, delay)
  }
}

input.onkeypress = debounce(function(){
  // ajax request
}, 500)
```

每次事件触发回调函数均会将之前的计时器重置：
1. 如果两次回调函数的触发事件间隔 > delay，计时器清空不影响前一次回调函数的执行（因为已经执行过了），两次回调函数都得到执行
2. 如果两次回调函数的触发事件间隔 < delay，由于计时器清空，导致前一次回调函数得不到执行（在delay时刻到来之前被重置）
3. 如果继续有事件触发了回调函数，且触发时间间隔均在delay内，则导致之前的回调函数均得不到执行。

一般用于处理事件的回调，事件会频繁触发，但是对事件的回调函数的执行进行控制。

#### 函数节流
规定在一个单位时间内，只能有一个函数回调得到执行。

```js
function throttle (fn, delay) {
  let timer
  // throttle处理回调函数时 打点
  let startTime = new Date()
  return function () {
    const conText = this
    const args = arguments
    clearTimeout(timer)
    const currentTime = new Date()
    // 首次触发一般距离绑定事件监听时间> delay
    if (currentTime - startTime > delay) {
      fn.apply(conText, args)
      startTime = currentTime
    } else {
      // 保证最后一次回调一定被执行
      timer = setTimeout(function () {
        fn.apply(conText, args)
      }, delay)
    }
  }
}
```

1. 如果两次回调函数的触发事件间隔 > delay，计时器清空不影响前一次回调函数的执行（因为已经执行过了），两次回调函数都得到执行
2. 如果两次回调函数的触发事件间隔 < delay，由于计时器清空，导致前一次回调函数得不到执行（在delay时刻到来之前被重置）
3. 如果继续有事件触发了回调函数，且触发时间间隔均在delay内，则导致之前的回调函数均得不到执行。

#### 适用的场景
___
#### 参考
<!-- 1. []() -->