#### 函数防抖

在事件被触发delay时间间隔后再执行回调，如果在这delay时间内又被触发，则重新计时。
```javascript
function debounce (fn, delay) {
  let timer
  return function () {
    const context = this
    const args = arguments
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, delay)
  }
}

input.onkeypress = debounce(function(){
  // ajax request
}, 500)
```
  一般用于处理事件的回调，事件会频繁触发，但是对事件的回调函数的执行进行控制。


  #### 函数节流

规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
```javascript
function throttle (fn, delay) {
  let timer
  let startTime = new Date()
  return function () {
    const conText = this
    const args = arguments
    clearTimeout(timer)
    const currentTime = new Date()
    if (currentTime - startTime > delay) {
      fn.apply(conText, args)
      startTime = currentTime
    } else {
      // 保证最后一次回调一定被执行
      timer = setTimeout(function () {
        fn.apply(conText, args)
      }, delay)
    }
  }
}
```