#### 判断是否为数组
1.`instanceof`方法

    arr instanceof  Array
2.`constructor`

    arr.constructor == Array
3.`toString`

    Object.prototype.toString.call(arr)
    //[object Array]

4.`isArray`方法

    Array.isArray(arr);

#### 判断是否为字符串
1.`toString`

    Object.prototype.toString.call(str)
    //[object String]
    
#### 严格模式下('use strict')进行JavaScript开发有什么好处？

- 消除JavaScript语法的一些不合理、不严谨之处，减少怪异行为；
- 消除代码运行的不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；

在严格模式下：

- 变量必须声明才能使用
- 闭包内的this不再指向全局对象
- 对象属性和函数形参不能重复声明
- call和callee无法使用
- with无法使用
- 创建了一种新的作用域：eval作用域：


	    "use strict";
	    var x = 2;
	    console.info(eval("var x = 5; x")); // 5
	    console.info(x); // 2


#### 关于eval
`eval`只有在**直接调用**并且调用函数就是`eval`本身时，才会在当前作用域中执行。

    var foo = 1;
    
    function test() {
        var foo = 2;
        eval('foo = 3');
        return foo;
    }
    
    test(); // 3
    foo; // 1
    
看这一段：

    var foo = 1;
    
    function test() {
        var foo = 2;
        var bar = eval;
        bar('foo = 3');
        return foo;
    }
    
    test(); // 2
    foo; // 3
应该避免使用`eval`函数，99.9%的使用`eval`的场景都有**不使用**`eval`的解决方案。

#### 手动实现继承

许多OO语言都支持两种继承方式：**接口继承和实现继承**,接口继承继承方法签名，实现继承继承实际的方法。
在ECMAScript中，由于函数没有签名，无法实现接口继承，只支持实现继承。实现继承主要依靠原型链实现。

    function Parent(){
    
    }
    Parent.prototype.showJob = function(){
		
	}
	function Child(){
	
	}
	Child.prototype = new Parent();
	Child.prototype.constructor = Child;
	var grandChild = new Child();

这样，grandchild继承了构造函数Parent的原型方法。

#### 正则去除字符串的首尾空格

    var str = " dai you kongge de zi fuchuan !  ";
    var reg = /^\s*|\s*$/g;
    str.replace(reg, '')

#### CSS的link和import的区别

1.加载顺序不同，import会等到页面加载完之后再加载；
2.兼容问题：import是css2.1提出的，老版本浏览器不支持；

#### box-sizing
用于控制元素的盒模型的解析模式，默认为content-box。

content-box：让元素维持W3C的标准盒模型，元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高
border-box：让元素维持IE传统盒模型，设置width/height属性指的是border + padding + content


#### 清除浮动
1.为什么要清除浮动？

当一个内层元素是浮动的时候，如果没有关闭浮动时，其父元素也就不会再包含这个浮动的内层元素，因为此时浮动元素已经脱离了文档流，导致外层不会被撑开。

2.如何清除浮动？

- 在内层中添加元素，且其css样式设置为：

    clear:both;
- 在父层元素中添加css样式：

    overflow;auto;
- 使用:after伪元素：

    .father:after{
        content: '';
        display: block;
        clear: both;
    }

#### position


#### 进程和线程

1.进程

进程，是并发执行的程序在执行过程中的分配和管理资源的基本单位，是一个动态概念。每个进程都有自己独立的内存空间（大小与处理机位数有关）。在保护模式下，一个进程崩溃了，不会对其它进程产生影响。由于是独立的内存空间，上下文切换的时候需要先保存调用栈的信息，CPU各寄存器等信息，导致上下文切换时开销很大。
   
进程之间不共享任何状态，进程的调度由操作系统完成。进程间的通讯主要通过信号传递的方式实现：信号量，管道，事件等，任一种方式的通讯都要通过内核，导致通讯效率较低。