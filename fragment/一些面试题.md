#### 判断是否为数组
1.`instanceof`方法

    arr instanceof  Array
2.`constructor`

    arr.constructor == Array
3.`toString`

    Object.prototype.toString.call(arr)
    //[object Array]

4.`isArray`方法

    Array.isArray(arr);

#### 判断是否为字符串
1.`toString`

    Object.prototype.toString.call(str)
    //[object String]
    
#### 严格模式下('use strict')进行JavaScript开发有什么好处？

- 消除JavaScript语法的一些不合理、不严谨之处，减少怪异行为；
- 消除代码运行的不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；

在严格模式下：

- 变量必须声明才能使用
- 闭包内的this不再指向全局对象
- 对象属性和函数形参不能重复声明
- call和callee无法使用
- with无法使用
- 创建了一种新的作用域：eval作用域：


	    "use strict";
	    var x = 2;
	    console.info(eval("var x = 5; x")); // 5
	    console.info(x); // 2


#### 关于eval
`eval`只有在**直接调用**并且调用函数就是`eval`本身时，才会在当前作用域中执行。

    var foo = 1;
    
    function test() {
        var foo = 2;
        eval('foo = 3');
        return foo;
    }
    
    test(); // 3
    foo; // 1
    
看这一段：

    var foo = 1;
    
    function test() {
        var foo = 2;
        var bar = eval;
        bar('foo = 3');
        return foo;
    }
    
    test(); // 2
    foo; // 3
应该避免使用`eval`函数，99.9%的使用`eval`的场景都有**不使用**`eval`的解决方案。

#### 手动实现继承

许多OO语言都支持两种继承方式：**接口继承和实现继承**,接口继承继承方法签名，实现继承继承实际的方法。
在ECMAScript中，由于函数没有签名，无法实现接口继承，只支持实现继承。实现继承主要依靠原型链实现。

    function Parent(){
    
    }
    Parent.prototype.showJob = function(){
		
	}
	function Child(){
	
	}
	Child.prototype = new Parent();
	Child.prototype.constructor = Child;
	var grandChild = new Child();

这样，grandchild继承了构造函数Parent的原型方法。

#### 进程和线程

1.进程

进程，是并发执行的程序在执行过程中的分配和管理资源的基本单位，是一个动态概念。每个进程都有自己独立的内存空间（大小与处理机位数有关）。在保护模式下，一个进程崩溃了，不会对其它进程产生影响。由于是独立的内存空间，上下文切换的时候需要先保存调用栈的信息，CPU各寄存器等信息，导致上下文切换时开销很大。
   
进程之间不共享任何状态，进程的调度由操作系统完成。进程间的通讯主要通过信号传递的方式实现：信号量，管道，事件等，任一种方式的通讯都要通过内核，导致通讯效率较低。