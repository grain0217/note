在初步了解浏览器的多进程架构及浏览器内核后，我们接着来了解渲染引擎。

![渲染引擎结构](https://pic.downk.cc/item/5e65238098271cb2b89a1c67.jpg)

如图所示，渲染引擎主要由对浏览器接收到的网络资源进行解析的处理器组成——HTML解释器、CSS解释器、布局计算等。为了呈现渲染效果，渲染引擎依赖了网络、缓存、绘图工具、硬件加速机制等。

## 渲染过程
渲染引擎在获取文档后，大致进行了以下操作：

![渲染流程](https://pic.downk.cc/item/5e6547a198271cb2b8b9452b.jpg)

1. 通过**HTML解释器**解析HTML/SVG/XHTML文档，生成DOM树
2. 通过**CSS解释器**解析CSS生成CSS规则树
3. 通过DOM树和CSS规则树来构造渲染(render)树（渲染树不等于DOM树，因为像header、display为none之类的元素在渲染树中不存在）
4. 渲染树布局，又叫布局(`layout`)/回流(`reflow`)，计算每个元素的**尺寸**、**位置**
5. 渲染树绘制，又叫`paint`，绘制页面像素信息
6. 合成帧，浏览器将各层信息发送给**GPU**，GPU将各层合成，显示在屏幕上
7. 需要注意的是，在浏览器渲染完首屏页面后，如果对DOM进行操作会引起浏览器引擎对渲染树的重新布局和重新绘制，这叫做**重排**和**重绘**，显然，，**重绘发生时未必会触发渲染引擎的重排，但是重排必然会触发重绘**

上述渲染流程又称为**关键渲染路径（Critical Rendering Path）**。

在不同的浏览器内核（渲染引擎）下， 浏览器渲染的流程略有不同，如`Webkit`和`Geoko`对于CSS样式表的解析时机不同，对于解析过程中的描述术语也有不同，但是总体上工作流程是一致的。

### 一、HTML解析，构建DOM
以下面这段`HTML`为例：
```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

对于浏览器从磁盘或网络读取HTML文档的原始字节，渲染引擎是无法直接理解的，所以要将其转化为渲染引擎能够理解的内部结构——DOM，DOM提供了对HTML文档结构化的表述。

![DOM](https://pic.downk.cc/item/5ea7bcd3c2a9a83be597316e.png)

从上图可以看到，由HTML文档到DOM树，共经历了四个步骤：
1. **转化**： 浏览器从磁盘或网络读取HTML文档的原始字节流，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串，也就是前端er写的代码
2. **令牌(Token)化**： 浏览器将字符串转换成HTML标准规定的各种令牌，如`<html>`，`<body>`等用尖括号包含的字符串，标识出当前令牌是开始标签或者是结束标签，用于维护节点与节点之间的关系（父子、兄弟等）
3. **词法分析**： 将发出的令牌转换成节点对象，带有结束标签标识的令牌不会创建节点对象，节点对象包含了这个节点的所有属性；**注意：词法分析不是在所有Token都转换完成后才进行的，边生成Token边消耗Token**
4. **DOM构建**： 利用创建的节点之间的关系，所有节点对象连在一起构成了一个树状结构，便得到了一个完整的DOM树

### 二、CSS解析
在浏览器构建DOM树时，在HTML文档head部分解析到了`link`标记，该标记引用了一段外部样式表`style.css`，浏览器会请求该资源，我们假设它长这样:
```css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```

与解析HTML的过程一样，CSS解释器会将收到的CSS规则转换成浏览器能够理解和处理的东西：
![CSS解析](https://pic.downk.cc/item/5ebac694c2a9a83be5bfbf63.png)

CSS字节转换成字符，接着转换成令牌和节点，最后连在一起构成一个CSS对象模型(CSSOM)的树状结构：

![CSSOM树](https://pic.downk.cc/item/5ebacb11c2a9a83be5c88711.png)

要注意的是，上图中的树并不是完整的CSSOM树，它只显示了由样式表决定的样式。即使没有样式表，所有节点也会有一个计算样式，这是因为各浏览器都有自己的默认样式表。

**CSSOM树的构建和DOM树的构建是并行的**。在CSSOM树和DOM树均构建完毕后，才进入构建渲染树阶段。

### 三、构建渲染树
![构建渲染树](https://pic.downk.cc/item/5ebacd74c2a9a83be5cb49d4.png)

为了构建渲染树，浏览器大致做了以下工作：
1. 从根节点开始遍历DOM树的可见节点，下面两种不可见节点会被忽略：
    - 脚本标签、meta标签等
    - 通过CSS设置了隐藏的节点：`display: none`
2. 对于每个可见节点，为其找到并应用对应的CSSOM规则
3. 返回计算好样式的内容
4. 此外，**伪元素虽然不在DOM树上，却会出现在渲染树上**。

### 四、布局
渲染树给出屏幕上应该展示的所有可见节点的内容及其样式信息，接下来就需要计算这些节点在设备视口内的确切位置和尺寸，这一步就叫布局（layout/reflow）。

从渲染树的根节点开始遍历，渲染树上的每一个节点上都包含了宽高、位置、字体、背景色等信息，浏览器通过这些信息来确定每一个节点在页面上的确切位置和大小，

![布局](https://pic.downk.cc/item/5ece8e46c2a9a83be51bac88.jpg)

布局是一项具有挑战的任务。即使最简单的布局，比如块级元素从上到下的布局也必须考虑元素内部字体的大小，该如何换行，因为这些都会影响到该元素的形状和大小。甚至可能影响到下一个块级元素的位置。

布局阶段的输出就是一个盒模型：将所有相对测量值都转换成屏幕上的绝对像素。

### 五、绘制


## 渲染性能优化
___
### 参考
1. [浅析渲染引擎与前端优化](https://jdc.jd.com/archives/2806)
2. [详解渲染进程](https://blog.acohome.cn/inside-browser-part3/)
3. [浏览器渲染原理与过程](https://srtian96.gitee.io/blog/2018/06/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/)
4. [一文看懂Chrome浏览器运行机制](https://zhuanlan.zhihu.com/p/102149546)
5. [构建对象模型](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn)
6. [从8道面试题看浏览器渲染过程与性能优化](https://juejin.im/post/5e143104e51d45414a4715f7)
7. [浏览器的渲染原理简介](https://coolshell.cn/articles/9666.html)
8. [浏览器的渲染过程](https://zhuanlan.zhihu.com/p/74792085)
9. [](https://blog.acohome.cn/inside-browser-part3/)