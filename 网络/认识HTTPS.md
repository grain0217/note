### 为什么要用HTTPS
这个问题首先要从`HTTP`协议的缺陷讲起——我们知道，`HTTP`协议传输的数据明文传输的，而这些明文数据会经过WiFi、路由器、运营商、机房等物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫做`MITM`（Man In The Middle）中间人攻击。

除了网络黑客，我们使用的网络运营商也会扮演中间人的角色，有时候浏览网站会发现页面上多出来一大堆广告、红包按钮，这就是运营商劫持：
![运营商劫持](https://pic.downk.cc/item/5ebfd72bc2a9a83be51821a8.jpg)

因为运营商可以拿到响应的`HTML`并篡改它。

1994年，为了解决`HTTP`明文传输可能导致的安全问题，网景公司提出了`HTTPS`（HyperText Transfer Protocol Secure 超文本传输安全协议）。`HTTPS`协议其实非常简单，默认端口号443，至于其他的应答模式、报文结构、请求方法、URI、头字段、连接管理等等均沿用了`HTTP`。那么，你肯定想知道，`HTTPS`如何做到保证安全性呢？关键在于这个`S`——`SSL/TLS`。

### SSL/TLS协议
`SSL`（Secure Socket Layer，安全套接字）是一种安全协议，用于在客户端和服务端的通信中建立加密链接。而`TLS`（Transport Layer Security，安全传输层）是`SSL`的升级版，事实上我们现在用的都是基本都是`TLS`，`SSL`的1.0，2.0，3.0版本均已经被废弃，出于安全问题考虑广大浏览器也不再对老旧的`SSL`版本进行支持了，出于历史习惯现在将它们合在一起称为`SSL/TLS`。

通常情况下，`HTTP`会直接和`TCP` 进行通信。而在`HTTPS`协议中，与传输层的通信接口由 `SSL/TLS`替代，`HTTPS`本质上就是披了一层`SSL/TLS`的`HTTP`：
![HTTPS](https://pic.downk.cc/item/5ec00299c2a9a83be54f6063.png)

在这里对非对称加密、对称加密、公钥、私钥等概念就不再介绍，其实从字面就可以理解它们，具体的可以自行了解。

`SSL/TLS`协议的基本过程如下：
![TLS握手流程](https://pic.downk.cc/item/5ec00e81c2a9a83be55d6ca6.png)

#### 1. 客户端发出请求（ClientHello）
客户端发出加密通信请求，在这一步中，客户端在请求中要提供以下信息：
1. 支持的`TLS`协议版本
2. 客户端生成的一个随机数`sessionKey1`
3. 支持的加密方法
4. 支持的压缩方法

要清楚的是，在目前这一步的双方通信还处于明文传输阶段。

#### 2. 服务端响应（ServerHello）
收到客户端的加密通信请求后，服务端保留`sessionKey1`，并响应以下内容：
1. 确认使用的`TLS`协议版本
2. 服务端生成的一个随机数`sessionKey2`
3. 确认使用的加密方法
4. **服务器证书**

    其中，证书是由服务器向CA（Certificate Authority，证书认证机构）申请，由CA生成的，它由数字证书和数字签名组成：
    - **数字证书**
        - 证书版本号
        - 证书序列号
        - 证书有效期
        - 证书使用的签名算法
        - 证书颁发机构
        - 证书申请者的名称（人、服务器、组织、公司等）
        - 证书申请者的公钥`Pkey`（用于之后客户端和证书申请者即服务端协商对称加密通信使用的密钥）
        - ...
    - **数字签名**`Sig`
    ![证书的组成以及签名的生成](https://pic.downk.cc/item/5ec0264fc2a9a83be5769abf.jpg)

仍然是明文传输。

#### 3. 客户端响应
客户端收到服务端响应后，会按照以下步骤依次验证证书的合法性，校验不通过则不再继续后续步骤：
1. 读取证书中的证书所有者、有效期等信息进行校验
2. 查找操作系统中内置的受信任的证书发布机构CA，与证书中的CA比对

    ![CA证书的生成](https://pic.downk.cc/item/5ec01d66c2a9a83be56ce28d.jpg)

    可以看到，客户端能否信任证书，首先取决于客户端是否导入了CA的根证书
3. 使用CA的公钥（浏览器开发商发布版本时会内置CA公钥，**注意此处指的不是证书使用者的`Pkey`**)对证书里面的数字签名`Sig`进行解密，得到摘要`S1`
4. 读取证书中声明的签名算法，用该算法对证书的数字证书部分进行计算，将这个计算的hash摘要`S2`与上一步的`S1`比较，一致则认为证书合法

证书校验合法后，客户端从证书中取出公钥`Pkey`和`sessionKey2`，然后向服务端发送以下内容：
1. 一个随机数`sessionKey3`，使用`Pkey`进行加密
2. 编码通知改变，表示后续的信息都将用双方协商的加密方法和密钥进行加密通信
3. 客户端握手结束通知，表示客户端的握手阶段已经结束

在这一步中，`sessionKey3`已经是通过公钥`Pkey`加密的了，此时客户端通过`sessionKey1`+`sessionKey2`+`sessionKey3`可以计算出本次会话使用的会话密钥`SessionKey`。

#### 4. 服务器最后响应
服务端使用私钥解密，在提取出第三个`sessionKey3`之后，通过`sessionKey1`+`sessionKey3`+`sessionKey3`，计算生成本次会话最终使用的会话密钥`SessionKey`，然后向客户端发送以下信息：
1. 编码改变确认通知
2. 服务器握手结束通知，表示服务器的握手阶段已经结束

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用`SessionKey`进行对称加密和解密。

在握手阶段，在协商会话密钥`Session`的过程中，使用了三个随机数，因为不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于`SSL/TLS`协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

整个握手阶段可总结为：
1. 客户端、服务端通过非对称加密协商密钥`SessionKey`
2. 通过数字签名保证数字证书的合法

### 总结
`HTTPS`通过`SSL/TLS`加密`HTTP`数据，从而保证了通信安全。同时也因为引入加密解密带来了更多资源、通信时间消耗的问题。此外，从证书的选择、购买到部署也需要一笔开销。

关于`HTTPS`的基本原理就总结到这里，关于`HTTPS`性能优化的问题以后有时间再写。

___
### 参考
1. [HTTPS 原理详解](http://liuduo.me/2018/05/14/https-detail/)
2. [HTTPS 温故知新（三） —— 直观感受 TLS 握手流程(上)](https://halfrost.com/https_tls1-2_handshake/)
3. [HTTPS篇之SSL握手过程详解](https://razeencheng.com/post/ssl-handshake-detail)
