上节已经提到，`_update`方法用于将`VNode`渲染成真实的`DOM`，该方法有两个调用时机——一个首次渲染，一个是数据更新。本节仅分析首次渲染时`update`方法的执行，数据更新时的逻辑在后续的响应原理中分析。

```js
// src/core/instance/lifecycle.js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  if (!prevVnode) {
    // 首次渲染
    // 这里的vm.$el是之前在mountComponent方法内就挂载的，保存的是对一个真实DOM元素的引用
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
  } else {
    // 非首次渲染
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // update __vue__ reference
  if (prevEl) prevEl.__vue__ = null
  if (vm.$el) vm.$el.__vue__ = vm

  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) vm.$parent.$el = vm.$el
}
```

可以看到，
```js
vm.$el = vm.__patch__()
```
`_update`方法是通过调用`vm.__patch__`生成/更新真实`DOM`，然后将它赋值给`vm.$el`，Web平台下此方法定义在`src/platforms/web/runtime/index.js`中：

```js
import { patch } from './patch'

Vue.prototype.__patch__ = inBrowser ? patch : noop
```

由于在服务端渲染中，没有真实的浏览器`DOM`环境，**不需要把`VNode`最终转换成`DOM`**，因此在服务端渲染中`vm.__patch__`是一个空函数。浏览器渲染中，`Vue.prototype.__patch__`指向了`src/platforms/web/runtime/patch.js`中的`patch`方法：
```js
import * as nodeOps from 'web/runtime/node-ops'
import { createPatchFunction } from 'core/vdom/patch'
import baseModules from 'core/vdom/modules/index'
import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
const modules = platformModules.concat(baseModules)

const patch = createPatchFunction({ nodeOps, modules })
```

可以看到，`patch`方法是`createPatchFunction`方法的返回值，这里传入了两个参数：
- `nodeOps`：封装了一系列`DOM`操作的方法，如创建、插入、移除等
- `modules`：创建真实DOM也需要生成它的class/attrs/style等属性，modules是一个数组集合，数组的每一项都是这些属性对应的钩子方法，这些属性的创建、更新、销毁等都有对应钩子方法。比如它们都有create这个钩子方法，如将这些create钩子收集到一个数组内，需要在真实DOM上创建这些属性时，依次执行数组的每一项，也就是依次创建了它们。

在`createPatchFunction`方法内部，声明了很多辅助方法，最终返回了一个`patch`方法，这个方法正是`vm._update`方法内调用的`vm.__patch__`方法。

```js
//  src/core/vdom/patch.js
const hooks = ['create', 'activate', 'update', 'remove', 'destroy']

function createPatchFunction (backend) {
  let i, j
  const cbs = {}

  const { modules, nodeOps } = backend

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = []
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]])
      }
    }
  }

  function emptyNodeAt () {}
  function createRmCb () {}
  function removeNode () {}
  function isUnknownElement () {}
  function createElm () {}
  // function ...

  /**
   * oldVnode表示旧的VNode节点，它也可以不存在或者是一个DOM对象
   * vnode表示执行_render后返回的VNode的节点
   * hydrating表示是否是服务端渲染
   * removeOnly是给transition-group用的
   */
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      // 如果新的vnode不存在，老的vnode存在，那么销毁老的vnode，返回undefined
      // vm.$el = undefined操作会将页面中对应的元素销毁掉
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // 如果oldVnode未定义则说明是创建
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      // 创建元素
      createElm(vnode, insertedVnodeQueue)
    } else {
      // 根实例会走else，因为vm.$el不为空，即第一次渲染会进else
  
      // 是否是真实的DOM
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        // diff算法，新旧节点比对
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        // 创建根组件会走这个逻辑，因为首次渲染调用vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)，传入的是一个真实根节点
        if (isRealElement) {
          // 是真实的DOM
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            invokeInsertHook(vnode, insertedVnodeQueue, true)
            return oldVnode
          }
          // either not server-rendered, or hydration failed.
          // 创建一个空的节点
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // 创建一个新的DOM节点
        createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm))

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
}
```

在这里我们跟着下面这个例子分析`patch`的执行逻辑：
```js
var app = new Vue({
  el: '#app',
  render: function (createElement) {
    return createElement('div', {
      attrs: {
        id: 'app'
      },
    }, this.message)
  },
  data: {
    message: 'Hello Vue!'
  }
})
```

在`vm._update`中是这样调用`patch`方法的：
```js
vm.$el = vm.__patch(vm.$el, vnode, hydrating, false)
```

在首次渲染场景下，执行`patch`时传入的`vm.$el`是对`id`为`app`的DOM对象的引用，`vnode`对应的是调用`render`方法创建`VNode`，`hydrating`在非服务端渲染下为`false`，`removeOnly`为`false`。

回到`patch`方法的执行过程，由于`oldVnode`实际上是一个`DOM container`，`isRealElement`为`true`，
```js
oldVnode = emptyNodeAt(oldVnode)
```

`emptyNodeAt`方法将`oldVnode`转换成`VNode`对象，之后通过
```js
createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm))
```

将`vnode`转换成真实的`DOM`并插入到它的父节点中。

关于`createElm`方法的具体实现：
```js
// src/core/vdom/patch.js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  if (isDef(vnode.elm) && isDef(ownerArray)) vnode = ownerArray[index] = cloneVNode(vnode)

  vnode.isRootInsert = !nested // for transition enter check
  // createComponent方法用于创建子组件，只有vnode是子组件的时候createComponent返回true
  // 在当前场景下createComponent的返回为false，继续往下执行
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return
    
  const data = vnode.data
  const children = vnode.children
  const tag = vnode.tag
  if (isDef(tag)) {
    // 根据ns属性，选择不同方式创建真实DOM
    vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode)

    setScope(vnode)

    // 递归创建子节点元素，如果是组件会渲染组件的DOM
    createChildren(vnode, children, insertedVnodeQueue)
    if (isDef(data)) {
      // 执行create钩子，并把vnode push进insertedVnodeQueue中
      invokeCreateHooks(vnode, insertedVnodeQueue)
    }
    // 将生成的DOM插入到父节点中
    insert(parentElm, vnode.elm, refElm)
  } else if (isTrue(vnode.isComment)) {
    // 注释节点
    vnode.elm = nodeOps.createComment(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  } else {
    // 文本节点
    vnode.elm = nodeOps.createTextNode(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  }
}
```

`createComponent`方法用于创建子组件，这个方法在后面组件部分具体分析。`createChildren`方法用于创建子元素：
```js
function createChildren (vnode, children, insertedVnodeQueue) {
  if (Array.isArray(children)) {
    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(children)
    }
    for (let i = 0; i < children.length; ++i) {
      createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)
    }
  } else if (isPrimitive(vnode.text)) {
    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))
  }
}
```

可以看到，`createChildren`主要是遍历子虚拟节点，递归调用`createElm`方法，然后调用`invokeCreateHooks`执行所有的`create`钩子,并把`vnode` push 进`insertedVnodeQueue`中：
```js
function invokeCreateHooks (vnode, insertedVnodeQueue) {
  for (let i = 0; i < cbs.create.length; ++i) {
    cbs.create[i](emptyNode, vnode)
  }
  i = vnode.data.hook // Reuse variable
  if (isDef(i)) {
    if (isDef(i.create)) i.create(emptyNode, vnode)
    if (isDef(i.insert)) insertedVnodeQueue.push(vnode)
  }
}
```

最后通过`insert`方法把DOM插入到父节点中，由于是递归调用，子元素会优先调用`insert`，所以整个`vnode`树节点的插入顺序是先子后父：
```js
function insert (parent, elm, ref) {
  if (isDef(parent)) {
    if (isDef(ref)) {
      if (ref.parentNode === parent) {
        nodeOps.insertBefore(parent, elm, ref)
      }
    } else {
      nodeOps.appendChild(parent, elm)
    }
  }
}
```

关于`nodeOps`下的几个DOM操作的相关方法：
```js
// src/platforms/web/runtime/node-ops.js
function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode)
}

function appendChild (node, child) {
  node.appendChild(child)
}
```

在 createElm 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 vnode，它的 text 值取的就是之前的 this.message 的值 Hello Vue!。

再次回到`patch`方法，在首次渲染时调用了`createElm`方法，传入的`parentElm`是`oldVnode.elm`的父元素，在上文中给出的例子它是`id`为 `#app`的父元素，也就是`Body`；实际上整个过程就是递归创建了一个完整的`DOM`树并插入到`Body`上。

最后，根据之前递归`createElm`生成的`vnode`插入顺序队列，执行相关的`insert`钩子函数，这部分内容之后会详细介绍。

### 总结
![Vue渲染过程](https://pic.downk.cc/item/5f51fcd3160a154a67796338.png)

在这里只是分析了最简单的场景，在实际的开发中，我们是把页面拆分成很多组件的，这正是Vue的组件化思想。
