上一节讲到`_render`方法用于将实例转换为虚拟节点vnode，这是实例的私有方法，它是在`renderMixin(Vue)`阶段挂载到`Vue`原型上的：
```js
/**
* src/core/instance/render.js
*/
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options

  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots(
      _parentVnode.data.scopedSlots,
      vm.$slots,
      vm.$scopedSlots
    )
  }

  // 用$vnode保存父虚拟node
  vm.$vnode = _parentVnode
  let vnode
  try {
    // There's no need to maintain a stack becaues all render fns are called
    // separately from one another. Nested component's render fns are called
    // when parent component is patched.
    currentRenderingInstance = vm

    // render = vm.$options.render
    // 主线
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {
    handleError(e, vm, `render`)
    // return error render result,
    // or previous vnode to prevent render error causing blank component
    if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
      try {
        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
      } catch (e) {
        handleError(e, vm, `renderError`)
        vnode = vm._vnode
      }
    } else {
      vnode = vm._vnode
    }
  } finally {
    currentRenderingInstance = null
  }
  // vnode为数组且数组长度为1
  if (Array.isArray(vnode) && vnode.length === 1) {
    vnode = vnode[0]
  }
  // return empty vnode in case the render function errored out
  if (!(vnode instanceof VNode)) {
    if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
      warn(
        'Multiple root nodes returned from render function. Render function ' +
        'should return a single root node.',
        vm
      )
    }
    vnode = createEmptyVNode()
  }
  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

可以看到，在主线上，生成虚拟vnode的`_render`方法是通过执行`vm.$options.render.call(vm._renderProxy, vm.$createElement)`实现的，这里又有两个重要的方法——`vm.$options.render`和`vm.$createElement`。

### vm.$options.render
我们平时开发中手写`render`的场景较少，更多的是使用`template`模板，在3.0小节已经分析过，带`compiler`的Vue.js会在`$mount`执行前将`template`编译成`render`方法。

Vue.js的官方文档中介绍了`render`函数的第一个参数是`createElement`，

```js
<div id="app">
  {{ message }}
</div>
```

与

```js
render: function(createElement) {
  return createElement('div', {
    attrs: {
      id: 'app',
    },
  }, this.message)
}
```

是等效的。

与`vnode = vm.$options.render(vm._renderProxy, vm.createElement)`做一下比较，可以发现`render`方法中的`createElement`方法正是`vm.$createElement`方法。

### vm.$createElement
实例的`$createElement`方法是在`_init(vm)`阶段执行`vm.$mount(vm.$oprions.el)`方法之前通过`initRender(vm)`定义在实例上的：

```js
/**
* src/core/instance/render.js
*/
import { createElement } from '../vdom/create-element'

export function initRender (vm: Component) {
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)

  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
}
```

可以看到，在`$createElement`方法之外，`initRender`中还定义了一个`vm._c`方法，这个是在模板被编译成`render`函数时所使用，而`$createElement`是开发手写`render`方法时使用的（？？怎么看出来的），这两个方法支持的参数相同，且都是通过`createElement`实现的。

### 总结
本节分析了`vm._render`方法，在这里我们要记住一个主线，`_render`方法是用于生成虚拟节点vnode的，这个方法是在`renderMixin(Vue)`时挂载到Vue原型上的，它通过
```js
vnode = vm.$optoins.render.call(vm._renderProxy, vm.$createElement)
```
生成虚拟vnode并返回，其中`render`来自开发者手动提供或通过`template`编译生成，而`$createElement`是在`_init(vm)`阶段`initRender(vm)`时定义在实例上的，它又调用了`createElement`方法，这个方法将在后面单独分析。
