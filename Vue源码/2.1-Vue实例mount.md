前面已经分析过，Vue.js在`src/core/instance/init.js`下定义了构造器`Vue`，对`Vue`实例的初始化是从
```js
function Vue (options) {
  // balabala...
  this._init(options)
}
```
开始的，实例的`_init`方法是在`initMixin(Vue)`时在`Vue`原型上挂载的：

```js
export function initMixin (Vue: Class<Component>) {
  // 在Vue原型上挂载_init方法，该方法在new Vue(options)时执行用于初始化实例的$options

  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
  
    // 每个Vue实例都会有一个递增唯一的id标识
    vm._uid = uid++

    // 非生产环境对性能进行监控
    let startTag, endTag
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // 所有Vue的实例都被标记_isVue = true，它的作用是避免实例被响应系统observe?
    vm._isVue = true

    // 对用于初始化实例的options做了一层处理，然后赋值给实例属性$options
    if (options && options._isComponent) {
      // _isComponent 是一个内部选项，在创建组件实例的时候才会生成值为true
      // 优化组件实例的$options的初始化，因为动态选项合并非常慢，而且没有一个内部组件选项需要特殊处理?
      initInternalComponent(vm, options)
    } else {
      // 根实例的$options处理
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }


    if (process.env.NODE_ENV !== 'production') {
      // 在非生产环境下设置渲染函数的作用域代理，其目的是在开发阶段提供良好的提示信息（如在模板内访问实例上不存在的属性，则会给出准确的报错信息）
      initProxy(vm)
    } else {
      // 生产环境中，vm._renderProxy 是实例本身
      vm._renderProxy = vm
    }
  
    // expose real self
    vm._self = vm

    // 实例的生命周期相关变量初始化
    initLifecycle(vm)

    // 实例的事件监听初始化
    initEvents(vm)

    // 实例的编译render初始化
    initRender(vm)

    // 实例的beforeCreate生命钩子的回调
    callHook(vm, 'beforeCreate')

    // 实例在data/props初始化之前要进行绑定?
    initInjections(vm) // resolve injections before data/props
    
    // 实例state状态初始化
    initState(vm)

    // 实例在data/props之后要进行提供?
    initProvide(vm) // resolve provide after data/props

    // 实例的created生命钩子的回调
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    // 根据挂载点，调用挂载函数
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
```

在对`Vue`实例的初始化工作完成之后，检测到`$options.el`属性存在并使用`vm.$mount`方法挂载`Vue`实例，从而做到将模板+数据渲染成为最终的`DOM`。

#### $mount的实现
Vue.js中`$mount`方法的定义出现在三个模块中：`src/platform/web/entry-runtime-with-compiler.js`、`src/platform/web/runtime/index.js`、`src/platform/weex/runtime/index.js`，这是因为对`$mount`的定义是与平台、构建方式相关的。

在对`$mount`分析之前，先了解一下Vue.js基于源码构建的两个版本：
- runtime only 只包含运行时的版本
- runtime + compiler 同时包含编译器和运行时的版本

原型上的`$mount`方法是在`src/platform/web/runtime/index.js`中定义的（Runtime only版本），带`compiler`版本的Vue.js在`src/platform/web/entry-runtime-with-compiler.js`中复用了`Runtime only`版本的`$mount`，并用`compileToFunctions`实现了对`template`的编译工作。

在`src/platform/web/runtime/index.js`中，`$mount`定义如下：

```js
import Vue from 'core/index'
import { mountComponent } from 'core/instance/lifecycle'
import { inBrowser } from 'core/util/index'
import { query } from 'web/util/index'

/**
* $mount方法接收两个参数：
* el: 挂载的元素，可以是字符串，也可以是元素节点
* hydrating： 与服务端渲染相关，rutimeonly和带compiler版本下均不要传
*/
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

```

可以看到，`$mount`实际上调用了`mountComponent`方法，该方法定义在`src/core/instance/lifecycle.js `中：
```js
import { createEmptyVNode } from '../vdom/vnode'

export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // 使用$el保存对组件模板根元素的引用
  vm.$el = el

  if (!vm.$options.render) {
    // 渲染函数不存在, 则创建一个空的vnode对象
    vm.$options.render = createEmptyVNode

    // 告警
    if (process.env.NODE_ENV !== 'production') {
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  
  // 触发 beforeMount 生命周期钩子
  callHook(vm, 'beforeMount')

  // vm._render：调用render方法并返回生成的vnode template -> render -> vnode

  // vm._update：将_render生成的vnode渲染成真正的DOM，vnode -> DOM
  let updateComponent
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // 创建一个render函数的观察者？
  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  // 在watcher的回调中调用updateComponent
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    // vm.$vnode表示实例的父虚拟node，当$vnode为空表示当前实例是根实例
    vm._isMounted = true
    // 设置vm._ismounted，并触发mounted钩子函数
    callHook(vm, 'mounted')
  }
  return vm
}
```

`watcher`在这里有两个作用：
- 初始化实例时执行回调函数？
- 监测到vm实例中数据发生变化，执行回调函数？

#### 总结
`$mount`方法的执行依靠`mountComponent`，而`mountComponent`通过实例化一个`Watcher`，在其监听数据变化的回调中通过执行`vm._update(vm._render(), hydrating)`——`vm._render`将实例转换为虚拟vnode，而`vm._update`将虚拟vnode渲染更新为真正的DOM，从而完成整个渲染工作。