上一节讲到`_render`方法用于将实例转换为`vnode`对象，`_update`将生成的`vnode`渲染成真实的DOM。本文分析`vnode`的生成。

首先，要先搞明白`vnode`是什么。

### vnode是什么
由于浏览器标准把真实DOM设计得非常复杂，频繁地更新DOM会产生性能问题，`virtual DOM`也就有了舞台——虚拟DOM是用于描述DOM节点的原生JavaScript对象。

在Vue.js中，`virtual DOM`是用`vnode`描述的：
```js
// src/core/vdom/vnode.js
class VNode {
  constructor (tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.key = data && data.key
    this.componentInstance = undefined
    // ...
  }

  get child () {
    return this.componentInstance
  }
}
```

这里可以看到`VNode`中定义了一些关键属性——标签名、数据、子节点、键值等，其它属性都是用来扩展`VNode`的灵活性以及实现一些特殊的feature 。

`vnode`的生成看起来很简单——只要通过调用`new VNode()`并提供一系列初始化数据，接下来是我们在之前提到过的用于生成`vnode`的`_render`方法。

### 生成vnode的_render方法
`_render`是实例的私有方法，它在执行`renderMixin(Vue)`时被挂载到`Vue`原型上：
```js
// src/core/instance/render.js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots(
      _parentVnode.data.scopedSlots,
      vm.$slots,
      vm.$scopedSlots
    )
  }

  // 用$vnode保存父虚拟node
  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

这里：
```js
let vnode = render.call(vm._renderProxy, vm.$createElement)
```

涉及到两个重要的方法——`render`和`$createElement`。

`render`来源于`options`：它可能是开发者手写的`render`，也可能是由`template`编译成的`render`。由模板生成`render`的过程，在后面的分析中会单独做介绍，在这里暂讨论手写`render`的情况。

Vue.js的官方文档中介绍了手写`render`函数提供的第一个参数是`createElement`：
```js
render: function(createElement) {
  return createElement('div', {
    attrs: {
      id: 'app',
    },
  }, this.message)
}
```

将它与`_render`方法内的：
```js
const { render } = vm.$options
vnode = render.call(vm._renderProxy, vm.$createElement)
```

做一下比较，即可发现手写`render`方法中提供的`createElement`参数对应的正是`vm.$createElement`方法。

而`$createElement`是在`_init(vm)`阶段通过`initRender(vm)`定义在实例上的：
```js
// src/core/instance/render.js
import { createElement } from '../vdom/create-element'

function initRender (vm) {
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
}
```

可以看到除了`$createElement`方法，实例上还定义了`vm._c`方法——这个是在`render`方法来自模板编译生成情况下使用的，而`$createElement`是在`render`方法来自手写情况下使用的，它们都是通过调用`createElement`实现的，区别在于最后一个参数分别为`true`和`false`。

```js
// src/core/vdom/create-element
function createElement (context, tag, data, children, normalizationType, alwaysNormalize) {
  // alwaysNormalize：render来自手写时为true，否则为false
  if (Array.isArray(data) || isPrimitive(data)) {
    // 因为data必须为对象类型变量，如果传入的data为Array类型或基本类型，则认为无data，此时传递的data作为children处理
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) normalizationType = ALWAYS_NORMALIZE
  return _createElement(context, tag, data, children, normalizationType)
}
```

`createElement`做了一层封装，对参数进行了处理交给`_createElement`执行：如果`data`是数组或者是原始类型，则将其作为`children`处理。

```js
// src/core/vdom/create-element
function _createElement (context, tag, data, children, normalizationType) {
  // 动态component(is="something")
  if (isDef(data) && isDef(data.is)) tag = data.is
  if (!tag) {
    // 动态component被设置了不存在的组件名
    return createEmptyVNode()
  }

  // 哪种情况下 children会为function？
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }

  // 规范化children
  if (normalizationType === ALWAYS_NORMALIZE) children = normalizeChildren(children)
  else if (normalizationType === SIMPLE_NORMALIZE) children = simpleNormalizeChildren(children)

  // 创建VNode
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      vnode = new VNode(tag, data, children, undefined, undefined, context)
    }
  } else {
    vnode = createComponent(tag, data, context, children)
  }
  
  // 最后，对vnode再次做校验
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```

看起来稍微有点长，`_createElement`在这里主要做了两件事：
- `children`的规范化
- `VNode`的创建

### children规范化
由于`Virtual DOM`实际上是一个树状结构，每一个`VNode`实例可能会有若干个子节点，这些子节点也应该是`VNode`类型，而`_createElement`方法接收的参数`children`是任意类型的（发生在手写`render`时），因此需要将它规范成`VNode`类型。

```js
if (normalizationType === ALWAYS_NORMALIZE) {
  children = normalizeChildren(children)
} else if (normalizationType === SIMPLE_NORMALIZE) {
  children = simpleNormalizeChildren(children)
}
```

可以看到，对`children`的规范会处理是根据`normalizationType`的不同而调用了`normalizeChildren`和`simpleNormalizeChildren`两个方法，这两个方法的用处都是将`children`做扁平化处理并返回一个`VNode`的一维数组，它们都定义在`src/core/vdom/helpers/normalize-children`中：
```js
// src/core/vdom/helpers/normalize-children
// normalizeChildren的调用场景有两种：
// 一是render方法是由开发手写，当children只有一个节点的时候，Vue.js从接口层面允许用户将children写成基础类型用来创建单个简单文本节点，这种情况下会调用createTextVNode创建一个文本节点的VNode
// 另一种是编译slot、v-for产生嵌套数组的情况，调用normalizeArrayChildren方法

function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

// simpleNormalizeChildren的调用场景是render方法是由编译产生，理论上生成的children都是VNode类型，只需要针对children为函数式组件返回的是一个数组做处理
// Vue.js中函数式组件在哪些场景下使用？
function simpleNormalizeChildren (children) {
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}
```

`normalizeChildren`方法定义如下：

```js
function normalizeArrayChildren (children, nestedIndex) {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    if (isUndef(c) || typeof c === 'boolean') continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
        // 合并相邻Text节点
        if (isTextNode(c[0]) && isTextNode(last)) {
          // 为什么只需要考虑c[0]? 因为c的children中相邻的TextNode已经被合并为一个TextNode
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        // 将children中类型为数组的child拍平
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      // last为 1.TextNode 或 2.Array[TextNode]
      if (isTextNode(last)) {
        // 合并相邻TextNode
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        // 转为TextNode推入res
        res.push(createTextVNode(c))
      }
    } else {
      // 最后只剩下c为TextNode，而last可能为TextNode或Array<TextNode>两种case
      if (isTextNode(c) && isTextNode(last)) {
        // c本身为TextNode，且last也为TextNode
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // c为TextNode，last为Array<TextNode>
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}
```

经过以上规范化，`children`变成了类型为`VNode`的一维数组。

### VNode的创建
回到`_createElement`方法主流程中，在对`children`做规范化处理之后，接下来的工作是创建`vnode`实例：
```js
let vnode, ns
if (typeof tag === 'string') {
  // 字符串类型
  let Ctor
  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // config.isReservedTag定义在src/platform/web/util/element.js下
    // 这里用于判断tag是否为内置标签
    // 如果是则创建一个对应的VNode对象
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // resolveAsset定义在src/core/util/options.js下
    // 会依次通过普通命名、camelize、capitalize几种命名风格检查tag是否为已经注册的组件名
    // 如果是，则通过createComponent创建组件类型的VNode
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    vnode = new VNode(tag, data, children, undefined, undefined, context)
  }
} else {
  // 非字符串
  vnode = createComponent(tag, data, context, children)
}
```

其中，通过`createComponent`创建组件类型`VNode`的过程将在后面组件源码中分析。

<!-- ### 总结
本节分析了`vm._render`方法，在这里我们要记住一个主线，`_render`方法是用于生成`vnode`的，这个方法是在`renderMixin(Vue)`时挂载到Vue原型上的，它通过
```js
const render = vm.$optoins.render
vnode = render.call(vm._renderProxy, vm.$createElement)
```

生成虚拟vnode，其中`render`来自开发者手动提供或通过`template`编译生成，而`$createElement`是在`_init(vm)`阶段`initRender(vm)`时定义在实例上的，它又调用了`createElement`方法，这个方法将在下一节分析。 -->
