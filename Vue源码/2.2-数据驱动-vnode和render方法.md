上一节讲到`_render`方法用于将实例转换为`vnode`对象，`_update`将生成的`vnode`渲染成真实的DOM。本文分析`vnode`的生成。

首先，要先搞明白`vnode`是什么。

### 1.vnode是什么
由于浏览器标准把真实DOM设计得非常复杂，频繁地更新DOM会产生性能问题，`virtual DOM`也就有了舞台——虚拟DOM是用于描述DOM节点的原生JavaScript对象。

在Vue.js中，`virtual DOM`是用`vnode`描述的：
```js
// src/core/vdom/vnode.js
class VNode {
  constructor (tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.key = data && data.key
    this.componentInstance = undefined
    // ...
  }

  get child () {
    return this.componentInstance
  }
}
```

这里可以看到`VNode`中定义了一些关键属性——标签名、数据、子节点、键值等，其它属性都是用来扩展`VNode`的灵活性以及实现一些特殊的feature 。

`vnode`的生成看起来很简单——只要通过调用`new VNode()`并提供一系列初始化数据，接下来是我们在之前提到过的用于生成`vnode`的`_render`方法。

### 2.生成vnode的_render方法
`_render`是实例的私有方法，它在执行`renderMixin(Vue)`时被挂载到`Vue`原型上：
```js
// src/core/instance/render.js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  // 用$vnode保存父虚拟node
  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

这里：
```js
let vnode = render.call(vm._renderProxy, vm.$createElement)
```

又涉及到两个重要的方法——`render`和`$createElement`。

`render`来源于`options`：它可能是开发者手写的`render`，也可能是由`template`编译成的`render`。由模板生成`render`的case，在后面的分析中会单独做介绍，在这里暂讨论手写`render`的情况。

Vue.js的官方文档中介绍了手写`render`函数提供的第一个参数是`createElement`：
```js
render: function(createElement) {
  return createElement('div', {
    attrs: {
      id: 'app',
    },
  }, this.message)
}
```

将它与`_render`方法内的：
```js
const { render } = vm.$options
vnode = render.call(vm._renderProxy, vm.$createElement)
```

做一下比较，即可发现手写`render`方法中提供的`createElement`参数对应的正是`vm.$createElement`方法。

而`$createElement`是在`_init(vm)`阶段通过`initRender(vm)`定义在实例上的：
```js
// src/core/instance/render.js
import { createElement } from '../vdom/create-element'

function initRender (vm) {
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
}
```

可以看到除了`$createElement`方法，实例上还定义了`vm._c`方法——这个是在`render`方法来自模板编译生成情况下使用的，而`$createElement`是在`render`方法来自手写情况下使用的，它们都是通过调用`createElement`实现的，区别在于最后一个参数分别为`true`和`false`：
```js
// src/core/vdom/create-element
function createElement (context, tag, data, children, normalizationType, alwaysNormalize) {
  // alwaysNormalize：render来自手写时为true，否则为false
  if (Array.isArray(data) || isPrimitive(data)) {
    // 因为data必须为对象类型变量，如果传入的data为Array类型或基本类型，则认为无data，此时传递的data作为children处理
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) normalizationType = ALWAYS_NORMALIZE
  return _createElement(context, tag, data, children, normalizationType)
}
```

`createElement`做了一层封装，如果`data`是数组或者是原始类型，则将其作为`children`处理，作为参数传给`_createElement`：
```js
// src/core/vdom/create-element
function _createElement (context, tag, data, children, normalizationType) {
  // 规范化children
  if (normalizationType === ALWAYS_NORMALIZE) children = normalizeChildren(children)
  else if (normalizationType === SIMPLE_NORMALIZE) children = simpleNormalizeChildren(children)

  // 创建vnode
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    if (config.isReservedTag(tag)) {
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context)
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      vnode = new VNode(tag, data, children, undefined, undefined, context)
    }
  } else {
    // 组件vnode
    vnode = createComponent(tag, data, context, children)
  }
  return vnode
}
```

`_createElement`在这里主要做了两件事：
- `children`的规范化
- `vnode`的创建

#### 2.1 children规范化
`_createElement`方法接收的参数`children`可能是任意类型的，因此需要将它规范成`VNode`类型：
```js
if (normalizationType === ALWAYS_NORMALIZE) {
  // render函数是手写
  children = normalizeChildren(children)
} else if (normalizationType === SIMPLE_NORMALIZE) {
  // render是编译生成
  children = simpleNormalizeChildren(children)
}
```

根据`normalizationType`的不同：
- `ALWAYS_NORMALIZE`：`render`函数来自手写，调用`normalizeChildren`
- `SIMPLE_NORMALIZE`：`render`是编译生成，调用`simpleNormalizeChildren`

这两个方法的作用都是将`children`做扁平化处理并返回一个`VNode`的一维数组：
```js
// src/core/vdom/helpers/normalize-children
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children) ? normalizeArrayChildren(children) : undefined
}

function simpleNormalizeChildren (children) {
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}
```

`normalizeChildren`方法定义如下：
```js
function normalizeArrayChildren (children, nestedIndex) {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    if (isUndef(c) || typeof c === 'boolean') continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
        // 合并相邻Text节点
        if (isTextNode(c[0]) && isTextNode(last)) {
          // 为什么只需要考虑c[0]? 因为c的children中相邻的TextNode已经被合并为一个TextNode
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        // 将children中类型为数组的child拍平
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      // last为 1.TextNode 或 2.Array[TextNode]
      if (isTextNode(last)) {
        // 合并相邻TextNode
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        // 转为TextNode推入res
        res.push(createTextVNode(c))
      }
    } else {
      // 最后只剩下c为TextNode，而last可能为TextNode或Array<TextNode>两种case
      if (isTextNode(c) && isTextNode(last)) {
        // c本身为TextNode，且last也为TextNode
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // c为TextNode，last为Array<TextNode>
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}
```

经过以上规范化，`children`变成了类型为`VNode`的一维数组。

#### 2.2 vnode的创建
回到`_createElement`方法主流程中，在对`children`做规范化处理之后，接下来的工作是创建`vnode`实例：
```js
let vnode, ns
if (typeof tag === 'string') {
  // 字符串类型
  let Ctor
  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // 这里用于判断tag是否为内置标签
    // 如果是则创建一个对应的VNode对象
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // 会依次通过普通命名、camelize、capitalize几种命名风格检查tag是否为已经注册的组件名
    // 如果是，则通过createComponent创建组件类型的VNode
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    vnode = new VNode(tag, data, children, undefined, undefined, context)
  }
} else {
  // 非字符串
  vnode = createComponent(tag, data, context, children)
}
```

其中，通过`createComponent`创建组件类型`VNode`的过程将在后面组件源码中分析。

