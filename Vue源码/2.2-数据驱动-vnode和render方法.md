上一节讲到`_render`方法用于将实例转换为`vnode`对象，`_update`将生成的`vnode`渲染成真实的DOM。本文分析`vnode`的生成。

首先，要先搞明白`vnode`是什么。

### 1.vnode是什么
由于浏览器标准把真实DOM设计得非常复杂，频繁地更新DOM会产生性能问题，`virtual DOM`也就有了舞台——虚拟DOM是用于描述DOM节点的原生JavaScript对象。

在Vue.js中，`virtual DOM`是用`vnode`描述的：
```js
// src/core/vdom/vnode.js
class VNode {
  constructor (tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.key = data && data.key
    this.componentInstance = undefined
    // ...
  }

  get child () {
    return this.componentInstance
  }
}
```

这里可以看到`VNode`中定义了一些关键属性——标签名、数据、子节点、键值等，其它属性都是用来扩展`VNode`的灵活性以及实现一些特殊的feature 。

`vnode`的生成看起来很简单——只要通过调用`new VNode()`并提供一系列初始化数据，接下来是我们在之前提到过的用于生成`vnode`的`_render`方法。

### 2.生成vnode的_render方法
`_render`是实例的私有方法，它在执行`renderMixin(Vue)`时被挂载到`Vue`原型上：
```js
// src/core/instance/render.js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  // 用$vnode保存父虚拟node
  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  if (Array.isArray(vnode) && vnode.length === 1) vnode = vnode[0]

  // set parent
  vnode.parent = _parentVnode
  return vnode
}
```

这里：
```js
let vnode = render.call(vm._renderProxy, vm.$createElement)
```

又涉及到两个重要的方法——`render`和`$createElement`。

`render`来源于`options`：它可能是开发者手写的`render`，也可能是由`template`编译成的`render`。由模板生成`render`的case，在后面的分析中会单独做介绍，在这里暂讨论手写`render`的情况。

Vue.js的官方文档中介绍了手写`render`函数提供的第一个参数是`createElement`：
![render](https://pic.downk.cc/item/5f549704160a154a670e7a4e.jpg)

将它与`_render`方法内的：
```js
const { render } = vm.$options
vnode = render.call(vm._renderProxy, vm.$createElement)
```

做一下比较，即可发现手写`render`方法中提供的`createElement`对应的正是`vm.$createElement`方法。

而`$createElement`是在`_init(vm)`阶段通过`initRender(vm)`定义在实例上的：
```js
// src/core/instance/render.js
import { createElement } from '../vdom/create-element'

function initRender (vm) {
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
}
```

可以看到除了`$createElement`方法，实例上还定义了`vm._c`方法——这个是在`render`方法来自模板编译生成情况下使用的，而`$createElement`是在`render`方法来自手写情况下使用的，它们都是通过调用`createElement`实现的，区别在于最后一个参数分别为`true`和`false`：
```js
// src/core/vdom/create-element
function createElement (context, tag, data, children, normalizationType, alwaysNormalize) {
  // alwaysNormalize：render来自手写时为true，否则为false
  if (Array.isArray(data) || isPrimitive(data)) {
    // 因为data必须为对象类型变量，如果传入的data为Array类型或基本类型，则认为无data，此时传递的data作为children处理
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) normalizationType = ALWAYS_NORMALIZE
  return _createElement(context, tag, data, children, normalizationType)
}
```

`createElement`做了一层封装，如果`data`是数组或者是原始类型，则将其作为`children`处理，紧接着传给`_createElement`处理：
```js
// src/core/vdom/create-element
function _createElement (context, tag, data, children, normalizationType) {
  // 规范化children
  if (normalizationType === ALWAYS_NORMALIZE) children = normalizeChildren(children)
  else if (normalizationType === SIMPLE_NORMALIZE) children = simpleNormalizeChildren(children)

  // 创建vnode
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    if (config.isReservedTag(tag)) {
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context)
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      vnode = new VNode(tag, data, children, undefined, undefined, context)
    }
  } else {
    // 组件vnode
    vnode = createComponent(tag, data, context, children)
  }
  return vnode
}
```

`_createElement`在这里主要做了两件事：
- `children`的规范化
- `vnode`的创建

#### 2.1 children规范化
`_createElement`方法接收的参数`children`可能是任意类型的，因此需要将它规范成`VNode`类型：
```js
if (normalizationType === ALWAYS_NORMALIZE) {
  // render来自手写
  children = normalizeChildren(children)
} else if (normalizationType === SIMPLE_NORMALIZE) {
  // render来自编译生成
  children = simpleNormalizeChildren(children)
}
```

根据`normalizationType`的不同：
- `ALWAYS_NORMALIZE`：`render`函数来自手写，调用`normalizeChildren`
- `SIMPLE_NORMALIZE`：`render`是编译生成，调用`simpleNormalizeChildren`

这两个方法的作用都是将`children`做扁平化处理并返回一个`VNode`的一维数组：
```js
// src/core/vdom/helpers/normalize-children
function normalizeChildren (children) {
  // children是基本数据类型，返回文本类型TextVNode；数组则使用normalizeArrayChildren做规范化
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children) ? normalizeArrayChildren(children) : undefined
}

function simpleNormalizeChildren (children) {
  // 编译render情况下，children各项一般已经是vnode，但是函数式组件返回的是数组：所以检查各项如果有数组则拍平
  for (let i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}
```

`normalizeChildren`方法定义如下：
```js
function normalizeArrayChildren (children, nestedIndex) {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    lastIndex = res.length - 1
    // res中最后一个vnode
    last = res[lastIndex]
    if (Array.isArray(c) && c.length) {
      // 递归
      c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
      // 合并相邻Text节点
      if (isTextNode(c[0]) && isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
        c.shift()
      }
      res.push.apply(res, c)
    } else if (isPrimitive(c)) {
      // 合并相邻TextNode
      if (isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        res.push(createTextVNode(c))
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // c本身为TextNode，且last也为TextNode
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        // c为TextNode，last为Array<TextNode>
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}
```

这里主要做了两件事情：对`children`为数组的进行递归处理以及合并相邻`TextVNode`，形如前面给出手写`render`的例子：
![children为规范化](https://pic.downk.cc/item/5f5497ae160a154a670ea5c3.jpg)

这里的`children`将会被处理为：
![children规范化](https://pic.downk.cc/item/5f54982d160a154a670ec053.jpg)

总之，经过child对`children`的规划化处理之后，`children`的每一项都为`VNode`类型。

#### 2.2 vnode的创建
回到`_createElement`方法主流程中，在对`children`做规范化处理之后，接下来的工作是创建`vnode`实例：
```js
let vnode
if (typeof tag === 'string') {
  // 字符串类型
  let Ctor
  if (config.isReservedTag(tag)) {
    // tag是否为内置标签
    vnode = new VNode(tag, data, children, undefined, undefined, context)
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // 如果是注册的组件名，则通过createComponent创建组件类型的vnode
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    vnode = new VNode(tag, data, children, undefined, undefined, context)
  }
} else {
  // 组件类型vnode
  vnode = createComponent(tag, data, context, children)
}
```

这里的`vnode`主要分为普通类型和组件类型，通过`createComponent`创建组件类型`vnode`的过程将在后面组件化中分析，前面给出的手写`render`创建的`vnode`最终如下：
![vnode](https://pic.downk.cc/item/5f549939160a154a670ef6d7.jpg)

### 总结
我们大致了解了`_render`方法创建`vnode`的过程，每个`vnode`都有`children`，`children`的每个元素也是一个`vnode`，这样就形成了一个`VNode Tree`，它可以简单的描述对应的`DOM Tree`。

接下来将分析如何把这个`vnode`渲染成一个真实的`DOM`——`update(vnode)`。

