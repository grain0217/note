创建完vnode接下来的步骤是`vm._update`——将vnode转化为真实DOM。

回顾`2.3`小节，在分析`update`内部调用的`createElm`方法(`vm._update -> vm.__patch__ -> createPatchFunction -> patch -> createElm`)的内部逻辑中：
```js
function createElm () {
  // 尝试处理组件vnode
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return

  // 非组件vnode的逻辑
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

第一步就是尝试处理组件vnode对应的DOM，当时跳过了此处`createComponent`的分析：
```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  // 组件vnode.data不为空
  let i = vnode.data
  if (isDef(i)) {
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      // 创建组件vnode时有合并钩子函数的操作，因此组件vnode的data中包含了init钩子，满足此条件
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      return true
    }
  }
}
```

### init钩子
回顾上一小节，组件类型的vnode在被创建时安装了`init`钩子，所以此时可以得到执行：
```js 
function init (vnode, hydrating) {
  if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```

`init`钩子的内部逻辑很简单（暂不考虑`keepAlive`组件的情况），对于普通组件vnode，会先通过`createComponentInstanceForVnode`创建一个新的**子组件实例**（记为`ch`）：
```js
function createComponentInstanceForVnode (vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }
  var inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

在这里`vnode.componentOptions.Ctor`对应的是子组件实例`ch`的构造函数，它是在创建组件vnode时写入`vnode.componentOptions`的。另外需要注意实例化子组件实例`ch`的参数`options`：
```js
{
  _isComponent: true,
  _parentVnode: vnode,
  parent: parent
}
```

`_isComponent`表示创建的Vue实例是一个**子组件**实例，`parent`表示**当前激活的组件实例**。

在通过组件vnode创建对应的根节点实例之后，将它赋给`vnode.componentInstance`来保留对子组件实例的引用，这里可以看出组件的`update`操作本质是通过创建子组件实例，借助子组件实例的`$mount`挂载实现。

在继续分析`createComponent`执行完`init`钩子之后的流程之前，我们先回顾一下Vue实例的`_init`方法：
```js
Vue.prototype._init = function (options) {
  const vm = this
  vm._uid = uid++
  vm._isVue = true

  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  } else {
    // 普通实例，合并options给vm.$options
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  initLifecycle(vm)
  // 事件、状态初始化操作...
}
```

创建子组件实例时，子组件的`_inti`方法会得到调用，由于`options._isComponent`为`true`走到了`initInternalComponent`的流程中去：
```js
function initInternalComponent (vm, options) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```
这里通过：
- opts.parent = options._parent
- opts._parentVnode = options._parentVnode

将`createComponentInstanceForVnode`接收的几个参数合并到子组件实例的`$options`中去。


再次回到组件的`init`钩子中，创建子组件实例`ch`后通过`ch.$mount`挂载子组件实例。子组件的`_render`：
```js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  // _parentVnode为父vnode
  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  if (Array.isArray(vnode) && vnode.length === 1) vnode = vnode[0]

  vnode.parent = _parentVnode
  return vnode
}
```

在生成子组件vnode时，子组件实例的`$vnode`保留了对父vnode的引用，生成的子组件实例对应的vnode的`parent`同样指向了父vnode，而在`_update`时：
```js
let activeInstance = null

function setActiveInstance(vm) {
  // 记录之前的激活的Vue实例
  const prevActiveInstance = activeInstance
  activeInstance = vm
  // 返回的方法用于重置激活的Vue实例
  return () => {
    activeInstance = prevActiveInstance
  }
}

Vue.prototype._update = function (vnode, hydrating) {
  const vm = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  // 将activeInstance指向当前执行_update操作的Vue实例
  const restoreActiveInstance = setActiveInstance(vm)
  // 将实例对应的vnode记录在vm._vnode上
  vm._vnode = vnode
  if (!prevVnode) {
    // 新建
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
  } else {
    // 更新
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  // 重置activeInstance
  restoreActiveInstance()

  if (prevEl) prevEl.__vue__ = null
  if (vm.$el) vm.$el.__vue__ = vm

  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}
```

`vnode`是由子组件实例`ch._render`生成的，`vm._vnode = vnode`使得子组件实例的`_vnode`属性指向了`vnode`，所以有`ch._vnode.parent === ch.$vnode`，子组件实例的`$vnode`和`_vnode`相当于是父子关系。

`activeInstance`是一个全局变量，用于保持对当前Vue实例的引用——Vue的实例化是一个深度优先的遍历过程，在实例化子组件时需要知道当前上下文Vue实例是什么。在上面子组件的实例化过程已经提到过，`ch._init`方法会先走到`initInternalComponent`流程中去——将父vnode和父组件实例合并到子组件实例的`$options`中。紧接着的`initLifecycle(vm)`：
```js
function initLifecycle (vm) {
  const options = vm.$options

  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  // ...
}
```

可以看到，实例的`$parent`指向了父实例，`parent.$children.push(vm)`将当前实例推入父实例的`$children`数组中。

在实例的`_update`过程中，`activeInstance`指向了当前实例，在当前实例的`__patch__`完成后，`activeInstance`重新指向它的父实例，这样保证了`createComponentInstanceForVnode`的遍历是深度优先的。

回到`_update`中，当前实例的`__patch__`：
```js
if (!prevVnode) {
  // 新建
  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
} else {
  // 更新
  vm.$el = vm.__patch__(prevVnode, vnode)
}

function patch (oldVnode, vnode, hydrating, removeOnly) {
  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    // ...
  }
}
```

这里又回到了本节开始的地方`createElm`：
```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }

  const data = vnode.data
  const children = vnode.children
  const tag = vnode.tag
  if (isDef(tag)) {
    vnode.elm = vnode.ns
      ? nodeOps.createElementNS(vnode.ns, tag)
      : nodeOps.createElement(tag, vnode)
    setScope(vnode)

    if (__WEEX__) {
      // ...
    } else {
      createChildren(vnode, children, insertedVnodeQueue)
      if (isDef(data)) {
        invokeCreateHooks(vnode, insertedVnodeQueue)
      }
      insert(parentElm, vnode.elm, refElm)
    }
    // ...
  } else if (isTrue(vnode.isComment)) {
    vnode.elm = nodeOps.createComment(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  } else {
    vnode.elm = nodeOps.createTextNode(vnode.text)
    insert(parentElm, vnode.elm, refElm)
  }
}
```

注意，这里我们传入的vnode是组件渲染的vnode，也就是之前说的`vm._vnode`，如果组件的根节点是个普通元素，那么`vm._vnode`也是普通的 vnode，这里`createComponent(vnode, insertedVnodeQueue, parentElm, refElm)`的返回值是`false`。接下来的过程就和我们上一章一样了，先创建一个父节点占位符，然后再遍历所有子vnode递归调用`createElm`，在遍历的过程中，如果遇到子vnode是一个组件的vnode，则重复本节开始的过程，这样通过一个递归的方式就可以完整地构建了整个组件树。

### 子组件的initComponent和insert
回到`createComponent`中，在组件的`init`钩子执行完后，会有一个子组件实例生成并被挂到`vnode.componentInstance`上，因此：
```js
if (isDef(vnode.componentInstance)) {
  initComponent(vnode, insertedVnodeQueue)
  insert(parentElm, vnode.elm, refElm)
  if (isTrue(isReactivated)) {
    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
  }
  return true
}
```

`initComponent(vnode, insertedVnodeQueue)`
