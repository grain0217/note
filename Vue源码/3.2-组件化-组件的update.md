创建完vnode接下来的步骤是`vm._update`——将vnode转化为真实DOM。

回顾`2.3`小节，在分析`update`内部调用的`createElm`方法(`vm._update -> vm.__patch__ -> createPatchFunction -> patch -> createElm`)的内部逻辑中：
```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // 尝试处理组件vnode
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return

  // 非组件vnode的逻辑
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

第一步就是尝试处理组件vnode对应的`patch`，普通vnode则会跳过它。`createComponent`的逻辑：
```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      // 创建组件vnode时有合并钩子函数的操作，因此组件vnode的data中包含了init钩子，满足此条件
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      return true
    }
  }
}
```

### init钩子
回顾上一小节，组件类型的vnode在被创建时安装的`init`钩子，此时可以得到执行：
```js 
function init (vnode, hydrating) {
  if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```

`init`钩子的内部逻辑很简单（暂不考虑`keepAlive`组件的情况），对于普通组件vnode，会先通过`createComponentInstanceForVnode`创建一个新的**子组件实例**（记为`ch`）：
```js
function createComponentInstanceForVnode (vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }
  var inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

在这里`vnode.componentOptions.Ctor`对应的是子组件实例`ch`的构造函数，前面一节已经讲到过，它是在`createComponent`中创建的，并在创建组件vnode时写入`vnode.componentOptions`中。另外需要注意实例化子组件实例`ch`的参数`options`：
```js
{
  _isComponent: true,
  _parentVnode: vnode,
  parent: parent
}
```

`_isComponent`表示创建的Vue实例是一个**子组件**实例，`parent`表示**当前激活的组件实例**。

在通过组件vnode创建对应的根节点实例之后，将它赋给`vnode.componentInstance`来保留对子组件实例的引用。组件实例在`init`钩子执行完后`vnode.componentInstance`不为空，`createComponent`会返回`true`，阻断`createElm`中后续处理普通vnode的逻辑。因为组件的`update`操作本质是通过创建子组件实例，借助子组件实例的`$mount`实现组件实例本身的`update`。

在继续分析`createComponent`执行完`init`钩子之后的流程之前，我们先回顾一下Vue实例的`_init`方法：
```js
Vue.prototype._init = function (options) {
  const vm = this
  vm._uid = uid++
  vm._isVue = true

  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  } else {
    // 普通实例，合并options给vm.$options
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  initLifecycle(vm)
  // 事件、状态初始化操作...
}
```

创建子组件实例时，子组件的`_inti`方法会得到调用，对于子组件实例`options._isComponent`为`true`，走到`initInternalComponent`的流程中去：
```js
function initInternalComponent (vm, options) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```
这里通过：
- opts.parent = options._parent
- opts._parentVnode = options._parentVnode

将创建子组件实例时接收的几个参数合并到子组件实例的`$options`中去。

再次回到组件的`init`钩子中，创建子组件实例`ch`后通过`ch.$mount`挂载子组件实例。子组件的`_render`：
```js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  // _parentVnode为父vnode
  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  if (Array.isArray(vnode) && vnode.length === 1) vnode = vnode[0]

  vnode.parent = _parentVnode
  return vnode
}
```

在生成子组件vnode时，子组件实例的`$vnode`保留了对父vnode的引用，生成的子组件实例对应的vnode的`parent`同样指向了父vnode，而在`_update`时：
```js
let activeInstance = null

function setActiveInstance(vm) {
  // 记录之前的激活的Vue实例
  const prevActiveInstance = activeInstance
  activeInstance = vm
  // 返回的方法用于重置激活的Vue实例
  return () => {
    activeInstance = prevActiveInstance
  }
}

Vue.prototype._update = function (vnode, hydrating) {
  const vm = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  // 将activeInstance指向当前执行_update操作的Vue实例
  const restoreActiveInstance = setActiveInstance(vm)
  // 将实例对应的vnode记录在vm._vnode上
  vm._vnode = vnode
  if (!prevVnode) {
    // 新建
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
  } else {
    // 更新
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  // 重置activeInstance
  restoreActiveInstance()

  if (prevEl) prevEl.__vue__ = null
  if (vm.$el) vm.$el.__vue__ = vm

  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}
```

`vnode`是由子组件实例`ch._render`生成的，`vm._vnode = vnode`使得子组件实例的`_vnode`属性指向了`vnode`，所以有`ch._vnode.parent === ch.$vnode`，子组件实例的`$vnode`和`_vnode`相当于是父子关系。

`activeInstance`是一个全局变量，用于保持对当前Vue实例的引用——Vue的实例化是一个深度优先的遍历过程，在实例化子组件时需要知道当前上下文Vue实例是什么。在上面子组件的实例化过程已经提到过，`ch._init`方法会先走到`initInternalComponent`流程中去——将父vnode和父组件实例合并到子组件实例的`$options`中。紧接着的`initLifecycle(vm)`：
```js
function initLifecycle (vm) {
  const options = vm.$options

  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  // ...
}
```

可以看到，实例的`$parent`指向了父实例，`parent.$children.push(vm)`将当前实例推入父实例的`$children`数组中。

在实例的`_update`过程中，`activeInstance`指向了当前实例，在当前实例的`__patch__`完成后，`activeInstance`重新指向它的父实例，这样保证了`createComponentInstanceForVnode`的遍历是深度优先的。

回到`_update`中，当前实例的`__patch__`：
```js
if (!prevVnode) {
  // 新建
  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
} else {
  // 更新
  vm.$el = vm.__patch__(prevVnode, vnode)
}

function patch (oldVnode, vnode, hydrating, removeOnly) {
  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    // ...
  }
}
```

这里又回到了本节开始的地方`createElm`：
```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // 组件vnode创建子组件实例，通过子组件实例$mount实现组件的update
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }

  // 非组件vnode的处理流程
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

而这一次我们传入的vnode是子组件vnode，如果最初组件的根节点是个普通元素，那么此时的子组件vnode也是普通的vnode，`createComponent`的返回值是`false`，接下来的过程就和之前普通vnode的`update`一样了——先创建一个父节点占位符，然后再遍历所有子vnode递归调用`createElm`。在遍历的过程中，如果遇到子vnode是一个组件类型的vnode，则又会进入本节介绍的组件update的流程。如此一来，通过递归的方式便可以完整地构建出整个组件DOM。

### 子组件的initComponent和insert
回到组件的`createComponent`中，在组件的`init`钩子执行完后，会有一个子组件实例生成并被挂到`vnode.componentInstance`上，在子组件实例`vnode.componentInstance.$mount`执行之后：
```js
if (isDef(vnode.componentInstance)) {
  initComponent(vnode, insertedVnodeQueue)
  insert(parentElm, vnode.elm, refElm)
  if (isTrue(isReactivated)) {
    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
  }
  return true
}
```

通过`insert`完成组件对应的DOM的插入。

### 总结
至此，一个组件vnode是如何创建、初始化、渲染的过程也就分析完了。在对组件化的实现有一个大概掌握后，接下来我们要来探究一下这其中的一些细节。
