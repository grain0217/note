创建完vnode接下来的步骤是`vm._update`——将vnode转化为真实DOM。

回顾`2.3`小节，在分析`update`内部调用的`createElm`方法(`vm._update -> vm.__patch__ -> createPatchFunction -> patch -> createElm`)的内部逻辑中：
```js
function createElm () {
  // 尝试处理组件vnode
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return

  // 非组件vnode的逻辑
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

第一步就是尝试处理组件vnode对应的DOM，当时跳过了此处`createComponent`的分析：
```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  // 组件vnode.data不为空
  let i = vnode.data
  if (isDef(i)) {
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      // 创建组件vnode时有合并钩子函数的操作，因此组件vnode的data中包含了init钩子，满足此条件
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      return true
    }
  }
}
```

### init钩子
回顾上一小节，组件类型的vnode在被创建时安装了`init`钩子，所以此时可以得到执行：
```js 
function init (vnode, hydrating) {
  if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```

`init`钩子的内部逻辑很简单（暂不考虑`keepAlive`组件的情况），对于普通组件vnode，会先通过`createComponentInstanceForVnode`创建一个新的**子组件实例**（记为`ch`）：
```js
function createComponentInstanceForVnode (vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }
  var inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

在这里`vnode.componentOptions.Ctor`对应的是子组件实例`ch`的构造函数，它是在创建组件vnode时写入`vnode.componentOptions`的。另外需要注意实例化子组件实例`ch`的参数`options`：
```js
{
  _isComponent: true,
  _parentVnode: vnode,
  parent: parent
}
```

`_isComponent`表示创建的Vue实例是一个**子组件**实例，`parent`表示**当前激活的组件实例**。

在通过组件vnode创建对应的根节点实例之后，将它赋给`vnode.componentInstance`来保留对子组件实例的引用，这里可以看出组件的`update`操作本质是通过创建子组件实例，借助子组件实例的`$mount`挂载实现。

在继续分析`createComponent`执行完`init`钩子之后的流程之前，我们先回顾一下Vue实例的`_init`方法：
```js
Vue.prototype._init = function (options) {
  const vm = this
  vm._uid = uid++
  vm._isVue = true

  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  } else {
    // 普通实例，合并options给vm.$options
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  // ...生命周期、事件、状态初始化操作...
}
```

创建子组件实例时，子组件的`_inti`方法会得到调用，由于`options._isComponent`为`true`走到了`initInternalComponent`的流程中去：
```js
function initInternalComponent (vm, options) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```
这里通过：
- opts.parent = options._parent
- opts._parentVnode = options._parentVnode

将`createComponentInstanceForVnode`接收的几个参数合并到子组件实例的`$options`中去。


再次回到组件的`init`钩子中，创建子组件实例`ch`后通过`ch.$mount`挂载子组件实例。子组件的`_render`：
```js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  if (Array.isArray(vnode) && vnode.length === 1) vnode = vnode[0]

  vnode.parent = _parentVnode
  return vnode
}
```

在生成子组件vnode时，子组件实例的`$vnode`保留了对父vnode的引用，生成的子组件实例对应的vnode的`parent`同样指向了父vnode，而在`_update`时：
```js
let activeInstance = null

function setActiveInstance(vm) {
  // 记录之前的激活的Vue实例
  const prevActiveInstance = activeInstance
  activeInstance = vm
  // 返回的方法用于重置激活的Vue实例
  return () => {
    activeInstance = prevActiveInstance
  }
}

Vue.prototype._update = function (vnode, hydrating) {
  const vm = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  // 将activeInstance指向当前执行_update操作的Vue实例
  const restoreActiveInstance = setActiveInstance(vm)
  // 将实例对应的vnode记录在vm._vnode上
  vm._vnode = vnode
  if (!prevVnode) {
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
  } else {
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  // 重置activeInstance
  restoreActiveInstance()
  if (prevEl) prevEl.__vue__ = null
  if (vm.$el) vm.$el.__vue__ = vm

  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}
```

子组件实例的`_vnode`指向了对应的vnode，所以有`ch._vnode.parent === ch.$vnode`，子组件实例的`$vnode`和`_vnode`可以相当于是父子关系。



### 子组件的initComponent和insert
```js
if (isDef(vnode.componentInstance)) {
  initComponent(vnode, insertedVnodeQueue)
  insert(parentElm, vnode.elm, refElm)
  if (isTrue(isReactivated)) {
    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
  }
  return true
}
```
