创建组件对应的vnode在前一章节已经分析过，创建完vnode接下来的步骤是执行`vm._update`——将vnode转化为真实DOM。

回顾`2.3`小节，在分析`update`内部调用的`createElm`方法(`vm._update -> vm.__patch__ -> createPatchFunction -> patch -> createElm`)的内部逻辑中，第一步就是尝试处理组件vnode：
```js
function createElm () {
  // 尝试处理组件vnode
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return

  // 非组件vnode的逻辑
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

`createComponent`：
```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      // 创建组件vnode时有合并钩子函数的操作，因此组件vnode的data中包含了init钩子，满足此条件
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      const isReactivated = i.keepAlive
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}
```

组件类型的vnode会满足`createComponent`内的条件，回顾上一节创建组件vnode时安装组件钩子函数的逻辑：
```js
function createComponentInstanceForVnode (vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }
  var inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}

const componentVNodeHooks = {
  // 根据组件vnode创建对应的的DOM时触发 
  init (vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      const mountedNode = vnode
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },
  // 其他钩子
  prepatch () {},
  insert () {},
  destroy () {}
}

function installComponentHooks (data) {
  const hooks = data.hook || (data.hook = {})
  for (let i = 0; i < hooksToMerge.length; i++) {
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}
```