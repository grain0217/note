本节讨论组件vnode的`patch`。

回顾`2.3`小节，vnode到DOM的实现借助了`createElm`方法：
```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // 尝试以组件vnode处理
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return

  // 非组件vnode的逻辑
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

第一步就是尝试以组件vnode的方式做`patch`：
```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  let i = vnode.data
  if (isDef(i)) {
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      return true
    }
  }
}
```

在前一节中已经提到，组件vnode的创建前有钩子函数的安装步骤，所以对于组件vnode其`data.hook.init`一定存在。所以组件vnode的`patch`，会经历以下三步：
1. 执行组件vnode的`init`钩子函数
2. `initComponent`
3. `insert`

### 1. init钩子
现在可以来看看`init`钩子做了哪些事情了：
```js 
function init (vnode, hydrating) {
  if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
    // keep-alive组件
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```

暂不考虑`keepAlive`的情况，这里会先通过`createComponentInstanceForVnode`创建**子组件实例**，前一节我们讨论的创建组件vnode前构造的组件类构造函数，在这里登场了：
##### 1.1 createComponentInstanceForVnode创建子组件实例
```js
function createComponentInstanceForVnode (vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }
  var inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  // vnode.componentOptions.Ctor为组件类构造函数
  return new vnode.componentOptions.Ctor(options)
}
```

对于：
```js
const vm = new Vue({
  el: '#app',
  render: h => h(App)
})
```

创建子组件`App`实例（记为`child`）的参数：
- `_isComponent`为`true`，区别于普通Vue实例
- `_parentVnode`维护了对父实例vnode的引用，即`options._parentVnode = vnode`
- `parent`维护了对父实例的引用，即`options.parent = vm`
  
子组件实例`child`创建完成后，父实例的vnode通过`componentInstance`维护了对`child`的引用——`vnode.componentInstance = child`。

下面我们来看刚刚构造的参数在实例化`child`过程中是如何作用的：
```js
Vue.prototype._init = function (options) {
  const vm = this
  vm._uid = uid++
  vm._isVue = true

  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  } else {
    // 普通实例，合并options给vm.$options
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  // 一系列事件、状态初始化操作...
  // $mount挂载
}
```

`options._isComponent`为`true`，所以`child.$options`的合并是由`initInternalComponent`完成的：
```js
function initInternalComponent (vm, options) {
  // 子组件实例的$options合并
  const opts = vm.$options = Object.create(vm.constructor.options)
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}
```

`opts`为对`child.$options`的引用，对其进行写操作导致：
- `child.$options.parent = options.parent`
- `child.$options._parentVnode = options._parentVnode`

子组件实例`child.$options`上保留了对父组件实例`vm`以及`vm`对应的vnode的引用。这些引用的作用后面再做讨论。

最后，由于初始化子组件实例`child`是不传`el`参数的：
```js
Vue.prototype._init = function (options) {
  const vm = this
  // $options初始化

  // 一系列事件、状态初始化操作...

  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```

所以`child.$mount`不是在`child._init`中调用的，它被放在了

##### 1.2 挂载组件实例
回到`init`钩子中，子组件实例`ch`创建后，通过`ch.$mount`挂载。子组件的`_render`：
```js
Vue.prototype._render = function () {
  const vm = this
  const { render, _parentVnode } = vm.$options

  // _parentVnode为父vnode
  vm.$vnode = _parentVnode
  let vnode = render.call(vm._renderProxy, vm.$createElement)

  if (Array.isArray(vnode) && vnode.length === 1) vnode = vnode[0]

  vnode.parent = _parentVnode
  return vnode
}
```

在生成子组件vnode时，子组件实例的`$vnode`保留了对父vnode的引用，生成的子组件实例对应的vnode的`parent`同样指向了父vnode，而在`_update`时：
```js
let activeInstance = null

function setActiveInstance(vm) {
  // 记录之前的激活的Vue实例
  const prevActiveInstance = activeInstance
  activeInstance = vm
  // 返回的方法用于重置激活的Vue实例
  return () => {
    activeInstance = prevActiveInstance
  }
}

Vue.prototype._update = function (vnode, hydrating) {
  const vm = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  // 将activeInstance指向当前执行_update操作的Vue实例
  const restoreActiveInstance = setActiveInstance(vm)
  // 将实例对应的vnode记录在vm._vnode上
  vm._vnode = vnode
  if (!prevVnode) {
    // 新建
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
  } else {
    // 更新
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  // 重置activeInstance
  restoreActiveInstance()

  if (prevEl) prevEl.__vue__ = null
  if (vm.$el) vm.$el.__vue__ = vm

  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}
```

`vnode`是由子组件实例`ch._render`生成的，`vm._vnode = vnode`使得子组件实例的`_vnode`属性指向了`vnode`，所以有`ch._vnode.parent === ch.$vnode`，子组件实例的`$vnode`和`_vnode`相当于是父子关系。

`activeInstance`是一个全局变量，用于保持对当前Vue实例的引用——Vue的实例化是一个深度优先的遍历过程，在实例化子组件时需要知道当前上下文Vue实例是什么。在上面子组件的实例化过程已经提到过，`ch._init`方法会先走到`initInternalComponent`流程中去——将父vnode和父组件实例合并到子组件实例的`$options`中。紧接着的`initLifecycle(vm)`：
```js
function initLifecycle (vm) {
  const options = vm.$options

  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  // ...
}
```

可以看到，实例的`$parent`指向了父实例，`parent.$children.push(vm)`将当前实例推入父实例的`$children`数组中。

在实例的`_update`过程中，`activeInstance`指向了当前实例，在当前实例的`__patch__`完成后，`activeInstance`重新指向它的父实例，这样保证了`createComponentInstanceForVnode`的遍历是深度优先的。

回到`_update`中，当前实例的`__patch__`：
```js
if (!prevVnode) {
  // 新建
  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false)
} else {
  // 更新
  vm.$el = vm.__patch__(prevVnode, vnode)
}

function patch (oldVnode, vnode, hydrating, removeOnly) {
  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    // ...
  }
}
```

这里又回到了本节开始的地方`createElm`：
```js
function createElm (
  vnode,
  insertedVnodeQueue,
  parentElm,
  refElm,
  nested,
  ownerArray,
  index
) {
  // 组件vnode创建子组件实例，通过子组件实例$mount实现组件的update
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
    return
  }

  // 非组件vnode的处理流程
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

而这一次我们传入的vnode是子组件vnode，如果最初组件的根节点是个普通元素，那么此时的子组件vnode也是普通的vnode，`createComponent`的返回值是`false`，接下来的过程就和之前普通vnode的`update`一样了——先创建一个父节点占位符，然后再遍历所有子vnode递归调用`createElm`。在遍历的过程中，如果遇到子vnode是一个组件类型的vnode，则又会进入本节介绍的组件update的流程。如此一来，通过递归的方式便可以完整地构建出整个组件DOM。

### 2. 组件的initComponent和insert
回到组件的`createComponent`中，在组件的`init`钩子执行完后，会有一个子组件实例生成并被挂到`vnode.componentInstance`上，在子组件实例`vnode.componentInstance.$mount`执行之后：
```js
if (isDef(vnode.componentInstance)) {
  initComponent(vnode, insertedVnodeQueue)
  insert(parentElm, vnode.elm, refElm)
  if (isTrue(isReactivated)) {
    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
  }
  return true
}
```

通过`insert`完成组件对应的DOM的插入。

### 总结
至此，一个组件vnode是如何创建、初始化、渲染的过程也就分析完了。在对组件化的实现有一个大概掌握后，接下来我们要来探究一下这其中的一些细节。
