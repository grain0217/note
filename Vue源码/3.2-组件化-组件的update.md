创建完vnode接下来的步骤是`vm._update`——将vnode转化为真实DOM。

回顾`2.3`小节，在分析`update`内部调用的`createElm`方法(`vm._update -> vm.__patch__ -> createPatchFunction -> patch -> createElm`)的内部逻辑中：
```js
function createElm () {
  // 尝试处理组件vnode
  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) return

  // 非组件vnode的逻辑
  const data = vnode.data
  const children = vnode.children
  // ...
}
```

第一步就是尝试处理组件vnode对应的DOM，当时跳过了此处`createComponent`的分析：
```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  // 组件vnode.data不为空
  let i = vnode.data
  if (isDef(i)) {
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      // 创建组件vnode时有合并钩子函数的操作，因此组件vnode的data中包含了init钩子，满足此条件
      i(vnode, false)
    }
    if (isDef(vnode.componentInstance)) {
      const isReactivated = i.keepAlive
      initComponent(vnode, insertedVnodeQueue)
      insert(parentElm, vnode.elm, refElm)
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
      }
      return true
    }
  }
}
```

### init钩子
回顾上一小节，组件类型的vnode在被创建时安装了`init`钩子，所以此时可以得到执行：
```js 
function init (vnode, hydrating) {
  if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
    const mountedNode = vnode
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
}
```

`init`钩子的内部逻辑很简单（暂不考虑`keepAlive`组件的情况），对于普通组件vnode，会先通过`createComponentInstanceForVnode`创建一个**对应的Vue实例**：
```js
function createComponentInstanceForVnode (vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }
  var inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  return new vnode.componentOptions.Ctor(options)
}
```

在这里`vnode.componentOptions.Ctor`对应的是组件的构造函数，它是在创建组件vnode时写入`vnode.componentOptions`的。另外需要注意实例化组件实例的参数`options`：
```js
{
  _isComponent: true,
  _parentVnode: vnode,
  parent: parent
}
```

`_isComponent`表示创建的Vue实例是一个组件实例，`parent`表示**当前激活的组件实例**。

在通过组件vnode创建对应的组件实例之后，将它赋给`vnode.componentInstance`来保留对组件实例的引用。然后通过调用组件实例的`$mount`方法挂载子组件，关于`$mount`的逻辑就再次回到之前的流程中去。

###
