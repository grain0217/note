在了解`nextTick`之前，需要清楚浏览器的事件循环机制，如果你还不清楚的话可以先阅读一下[这篇文章](https://www.baidu.com)。

在浏览器环境中，一轮事件循环可以理解为一个`tick`，那么`nextTick`相当于下一轮事件循环。在分析Vue的`nextTick`实现之前，我们要先弄明白为什么需要`nextTick`这个东西。

Vue的官方文档中提到过，**Vue在更新DOM时是异步执行的**。我们可以想象这样的场景：
1. 对某个响应式数据连续修改了多次
2. 对一个实例下的某几个响应式数据进行了修改

很显然在统一等待所有的响应式数据修改完成之后，一次性的进行DOM的更新就可以了。而如果DOM更新是同步的话，每一次响应式数据状态的改变都对应一次DOM更新，更新DOM的操作又涉及了非常多的计算，这疑会造成非常大的性能浪费。

因此一旦侦听到数据变化，Vue的做法是开启一个队列，将需要在同一事件循环中触发视图更新的`wathcer`存储进去，在下一轮事件循环中去执行它们的更新操作。

这就是Vue要实现`nextTick`的原因。

进入正题，`next-tick`中维护了`microTimerFunc`和`macroTimerFunc`两个方法，它们对应的分别是以`microTask`方式和`macroTask`方式处理`flushCallbacks`：
```js
// next-tick.js
const callbacks = []
let pending = false

function flushCallbacks () {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i < copies.length; i++) {
    copies[i]()
  }
}

let microTimerFunc
let macroTimerFunc
let useMacroTask = false

// macroTimerFunc
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () => {
    port.postMessage(1)
  }
} else {
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
// microTimerFunc
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () => {
    p.then(flushCallbacks)
    if (isIOS) setTimeout(noop)
  }
} else {
  microTimerFunc = macroTimerFunc
}
```

其中，`macroTask`的实现是按照`setImmediate > MessageChannel > setTimeout 0`三个方案的优先级降序检测采用的；而`microTask`则是先检测浏览器是否原生支持`Promise`，不支持则采纳`macro task`的方案。

而`flushCallbacks`做的事情就是遍历依次执行`callbacks`数组内保存的回调。

紧接着来看`nextTick`：
```js
function nextTick (cb, ctx) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      cb.call(ctx)
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
}
```

`nextTick`方法将需要执行的回调`cb`做了一层封装后压入`callbacks`数组，最后根据`useMacroTask`决定通过`macroTimerFunc`还是`microTimerFunc`去`flushCallbacks`，这就保证了`nextTick`所接收的回调会在下一轮事件循环中执行。

此外，`next-tick`还定义了`withMacroTask`方法，不像`nextTick`挂载在Vue的静态属性上那样可以供Vue用户使用，这是一个Vue框架内部使用的方法：
```js
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true
    const res = fn.apply(null, arguments)
    useMacroTask = false
    return res
  })
}
```

它对函数进行了封装，确保函数执行的过程中对数据进行修改触发的异步回调时通过`macroTimerFunc`执行的，一些DOM交互事件如`v-on`绑定事件回调函数的处理需要走`macroTask`。

### 总结
至此，我们知道了在Vue中响应式数据的修改到视图的更新是一个异步的过程，分析了`nextTick`的实现，加深了对浏览器的事件循环机制的认识。
