通过之前的源码分析，现在我们知道，创建的Vue实例有两种：一种是手动调用`Vue`构造函数创建的全局的`vm`，另一种是在做组件vnode的`patch`过程中创建的子组件实例。

无论哪种方式创建Vue实例，都会走到`vm._init(options)`的逻辑中去，在`1.2-Vue的定义`中提到过这一点，`_init`中有一段合并`options`的逻辑：
```js
Vue.prototype._init = function (options) {
  if (options && options._isComponent) {
    // 组件实例
    initInternalComponent(vm, options)
  } else {
    // 非组件实例
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  initLifecycle(vm)
  initEvents(vm)
  // ...
  vm.$mount(vm.$options.el)
}
```

先说结论：`mergeOptions`将`resolveConstructorOptions(vm.constructor)`的返回值与`options`合并。

### 1. resolveConstructorOptions
从名字上就可以看出`resolveConstructorOptions`的作用，解析并返回构造函数的`options`属性：
```js
function resolveConstructorOptions (Ctor) {
  var options = Ctor.options
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super)
    var cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions
      var modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) extend(Ctor.extendOptions, modifiedOptions)

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) options.components[options.name] = Ctor
    }
  }
  return options
}
```

对于构造函数Vue创建的`vm`，`vm.constructor`当然是`Vue`，而因为`Vue.super`为空，所以`resolveConstructorOptions`直接返回`Vue.options`。而对于组件级的`vm`，其`options`的解析还需要额外的处理逻辑。

我们先来看构造函数Vue的`options`属性。

#### 1.1 Vue.options
涉及`Vue.options`的写操作分散在两处：
```js
// src/core/global-api/index.js
function initGlobalAPI (Vue) {
  // ...初始为空
  Vue.options = Object.create(null)

  // ASSET_TYPES = ['component', 'directive', 'filter']
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  Vue.options._base = Vue

  // 将builtInComponents对象上的属性拷贝到Vue.options.components上
  extend(Vue.options.components, builtInComponents)
  // ... 其他全局方法
}

// src/platforms/web/runtime/index.js
// 将platformDirectives、platformComponents对象上的属性拷贝到Vue.options.directives、Vue.options.components上
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)
```

`initGlobalAPI(Vue)`初始化构造函数Vue的全局静态属性方法，以及安装平台runtime的`directives`和`components`时均涉及`Vue.options`的写入，最后它长这样：
![Vue.options](https://pic.downk.cc/item/5f588c47160a154a67f06d84.jpg)

#### 1.2 VueComponent.options
而对于组件构造函数，它们的`options`是通过`Vue.extend`继承自Vue的，这一点在`3.1`小节分析`createComponent`的内部逻辑时提到过：
```js
Vue.extend = function (extendOptions) {
  const Super = this

  // 定义子类构造函数
  const Sub = function VueComponent (options) {
    this._init(options)
  }

  // 合并父类的静态属性 options 和 传入的 extendOptions，形成子类的静态属性 options
  Sub.options = mergeOptions(
    Super.options,
    extendOptions
  )
  // 将子类的静态属性super指向父类
  Sub['super'] = Super

  // 在 Sub.prototype 上添加 props 和 computed 的便捷访问
  if (Sub.options.props) initProps(Sub)
  if (Sub.options.computed) initComputed(Sub)

  // 将子类自身注册为局部组件
  if (name) Sub.options.components[name] = Sub

  // 保持在继承时对父类Super.options的引用，以便于在之后实例化时检查Super.options是否更新过
  Sub.superOptions = Super.options
  Sub.extendOptions = extendOptions
  Sub.sealedOptions = extend({}, Sub.options)

  // ...

  return Sub
}
```

### 2. mergeOptions
```js
// src/core/util/options.js
function mergeOptions (parent, child, vm) {
  if (typeof child === 'function') child = child.options

  // 对options.props、options.inject、options.directives做规范化处理
  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // 只对未合并的options做处理，已合并的options._base不为空
  if (!child._base) {
    if (child.extends) parent = mergeOptions(parent, child.extends, vm)
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  for (let key in parent) mergeField(key)
  for (let key in child) {
    if (!hasOwn(parent, key)) mergeField(key)
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }

  return options
}
```

`mergeOptions`的主要作用是将`parent`、`child`合并成一个新的`options`并返回：
- 当`child`是未合并的`options`时，递归调用`mergeOptions`将`child.extends`、`child.mixins`合并到`parent`上
- 遍历`parent`、`child`，通过`mergeField`将`parent`、`child`对象上的属性挂到`options`上。
