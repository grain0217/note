通过之前的源码分析，现在我们知道，通过`new Vue`创建Vue实例的场景有两种：一种是手动调用去实例化一个全局的`vm`，另一种是组件内部实例化子组件`vm`。

无论哪种场景，在实例化`vm`时都会都会走到`vm._init(options)`的逻辑中去，在`1.2-Vue的定义`中提到过这一点，`_init`中有一段合并`options`的逻辑：
```js
Vue.prototype._init = function (options) {
  if (options && options._isComponent) {
    initInternalComponent(vm, options)
  } else {
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  initLifecycle(vm)
  initEvents(vm)
  // ...
  vm.$mount(vm.$options.el)
}
```

先说结论：`mergeOptions`将`resolveConstructorOptions(vm.constructor)`的返回值与`options`合并。

### 1. resolveConstructorOptions
从名字上就可以看出`resolveConstructorOptions`的作用，解析返回构造函数的`options`属性：
```js
function (Ctor) {
  var options = Ctor.options
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super)
    var cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions
      var modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) extend(Ctor.extendOptions, modifiedOptions)

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) options.components[options.name] = Ctor
    }
  }
  return options
}
```

对于手动创建的`vm`，`vm.constructor`当然是`Vue`，而因为`Vue.super`为空，所以`resolveConstructorOptions`直接返回`Vue.options`。而对于组件级的`vm`，其`options`的解析还需要额外的处理逻辑。

我们先来看`Vue.options`。

#### 1.1 Vue.options
涉及`Vue.options`的写操作分散在两处：
```js
// src/core/global-api/index.js
function initGlobalAPI (Vue) {
  // ...
  Vue.options = Object.create(null)

  // ASSET_TYPES = ['component', 'directive', 'filter']
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  Vue.options._base = Vue

  // 将builtInComponents对象上的属性拷贝到Vue.options.components上
  extend(Vue.options.components, builtInComponents)
  // ... 其他全局方法
}

// src/platforms/web/runtime/index.js
// 将platformDirectives、platformComponents对象上的属性拷贝到Vue.options.directives、Vue.options.components上
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)
```

`initGlobalAPI(Vue)`初始化构造函数Vue的全局静态属性方法，以及安装平台runtime的`directives`和`components`时均涉及`Vue.options`的写入，最后它长这样：
![Vue.options](https://pic.downk.cc/item/5f588c47160a154a67f06d84.jpg)

#### 1.2 VueComponent.options
而对于组件构造函数的`options`。

### 2. mergeOptions
```js
// src/core/util/options.js
function mergeOptions (parent, child, vm) {
  if (typeof child === 'function') child = child.options

  // 对options.props、options.inject、options.directives做规范化处理
  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // 只对未合并的options做处理，已合并的options._base不为空
  if (!child._base) {
    if (child.extends) parent = mergeOptions(parent, child.extends, vm)
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  for (let key in parent) mergeField(key)
  for (let key in child) {
    if (!hasOwn(parent, key)) mergeField(key)
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }

  return options
}
```

`mergeOptions`的主要作用是将`parent`、`child`合并成一个新的`options`并返回：
- 当`child`是未合并的`options`时，递归调用`mergeOptions`将`child.extends`、`child.mixins`合并到`parent`上
- 遍历`parent`、`child`，通过`mergeField`将`parent`、`child`对象上的属性挂到`options`上。
