通过之前的源码分析，现在我们知道，创建的Vue实例有两种：一种是手动调用`Vue`构造函数创建的全局的实例，另一种是在做组件vnode的`patch`过程中创建的子组件实例。

无论哪种方式创建Vue实例，都会调用实例的`_init(options)`方法，`_init`中首先有一段合并`options`的逻辑：
```js
Vue.prototype._init = function (options) {
  if (options && options._isComponent) {
    // 组件实例
    initInternalComponent(vm, options)
  } else {
    // 非组件实例
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  initLifecycle(vm)
  initEvents(vm)
  // ...
  vm.$mount(vm.$options.el)
}
```

根据实例的类型，`vm.options`的合并处理分为两种方式——`initInternalComponent`和`mergeOptions`。其中`initInternalComponent`在`3.2`小节已经分析过，本节仅分析`mergeOptions`。

在分析`mergeOptions`合并实例的`$options`的实现之前，我们先看一看实例的构造函数上的静态属性`options`。

### 1. Vue.options / VueComponent.options
涉及`Vue.options`的写操作分散在两处：
```js
// src/core/global-api/index.js
function initGlobalAPI (Vue) {
  // ...初始为空
  Vue.options = Object.create(null)

  // ASSET_TYPES = ['component', 'directive', 'filter']
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  Vue.options._base = Vue

  // 将builtInComponents对象上的属性拷贝到Vue.options.components上
  extend(Vue.options.components, builtInComponents)
  // ... 其他全局方法
}

// src/platforms/web/runtime/index.js
// 将platformDirectives、platformComponents对象上的属性拷贝到Vue.options.directives、Vue.options.components上
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)
```

`initGlobalAPI(Vue)`初始化构造函数Vue的全局静态属性方法，以及安装平台runtime的`directives`和`components`时均涉及`Vue.options`的写入，最后它长这样：
![Vue.options](https://pic.downk.cc/item/5f588c47160a154a67f06d84.jpg)

而对于组件实例来说，在`3.1`小节已经提到，组件的构造函数是在创建组件实例之前通过`Ctor.extend(options)`构造的，相应的，组件构造函数的`options`也会继承父类的`options`。

### 2. resolveConstructorOptions
`mergeOptions`：
```js
function resolveConstructorOptions (Ctor) {
  var options = Ctor.options
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super)
    var cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions
      var modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) extend(Ctor.extendOptions, modifiedOptions)

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) options.components[options.name] = Ctor
    }
  }
  return options
}
```

从名字上就可以看出，`resolveConstructorOptions`用来解析并返回构造函数的静态属性`options`。对于构造函数Vue，因为`Vue.super`为空，所以直接返回`Vue.options`。而对于组件构造函数，其`options`的解析还需要额外的处理。

### 3. mergeOptions
```js
// src/core/util/options.js
function mergeOptions (parent, child, vm) {
  if (typeof child === 'function') child = child.options

  // 对options.props、options.inject、options.directives做规范化处理
  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // 只对未合并的options做处理，已合并的options._base不为空
  if (!child._base) {
    if (child.extends) parent = mergeOptions(parent, child.extends, vm)
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  for (let key in parent) mergeField(key)
  for (let key in child) {
    if (!hasOwn(parent, key)) mergeField(key)
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }

  return options
}
```

`mergeOptions`的主要作用是将`parent`、`child`合并成一个新的`options`并返回：
- 当`child`是未合并的`options`时，递归调用`mergeOptions`将`child.extends`、`child.mixins`合并到`parent`上
- 遍历`parent`、`child`，通过`mergeField`将`parent`、`child`对象上的属性挂到`options`上。
