通过之前的源码分析，现在我们知道，创建的Vue实例有两种：一种是手动调用`Vue`构造函数创建的全局的实例，另一种是在做组件vnode的`patch`过程中创建的子组件实例。

无论哪种方式创建Vue实例，都会调用实例的`_init(options)`方法，`_init`中首先有一段合并`options`的逻辑：
```js
Vue.prototype._init = function (options) {
  if (options && options._isComponent) {
    // 组件实例
    initInternalComponent(vm, options)
  } else {
    // 非组件实例
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor),
      options || {},
      vm
    )
  }

  initLifecycle(vm)
  initEvents(vm)
  // ...
  vm.$mount(vm.$options.el)
}
```

根据实例的类型，分别通过`initInternalComponent`和`mergeOptions`将构造函数上的静态属性`options`与创建实例提供的参数合并到实例的`$options`上。其中`initInternalComponent`在`3.2`小节已经分析过，本节仅分析`mergeOptions`。

在分析`mergeOptions`的具体实现之前，我们先看一看实例的构造函数上的静态属性`options`。

### 1. Vue.options / VueComponent.options
涉及`Vue.options`的写操作主要分散在两处。一个地方是在`initGlobalAPI(Vue)`中，它的主要作用是初始化Vue的静态属性，其中包含了`Vue.options`：
```js
// src/core/global-api/index.js
function initGlobalAPI (Vue) {
  // ...初始为空
  Vue.options = Object.create(null)

  // ASSET_TYPES = ['component', 'directive', 'filter']
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  Vue.options._base = Vue

  // 将builtInComponents对象上的属性拷贝到Vue.options.components上
  extend(Vue.options.components, builtInComponents)
  // ... 其他全局方法
}
```

另一个地方是安装平台的runtime的`directives`和`components`时：
```js
// src/platforms/web/runtime/index.js
// 将platformDirectives、platformComponents对象上的属性拷贝到Vue.options.directives、Vue.options.components上
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)
```

最终，`Vue.options`长这个样子：
![Vue.options](https://pic.downk.cc/item/5f588c47160a154a67f06d84.jpg)

而对于组件实例来说，在`3.1`小节已经提到，组件的构造函数是在创建组件实例之前通过`Ctor.extend(options)`构造的，相应的，组件构造函数的`options`也会继承父类的`options`。

### 2. resolveConstructorOptions
`resolveConstructorOptions`方法用来解析出构造函数的静态属性`options`：
```js
function resolveConstructorOptions (Ctor) {
  var options = Ctor.options
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super)
    var cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions
      var modifiedOptions = resolveModifiedOptions(Ctor)
      if (modifiedOptions) extend(Ctor.extendOptions, modifiedOptions)

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) options.components[options.name] = Ctor
    }
  }
  return options
}
```

对于构造函数Vue，因为`Vue.super`为空，所以直接返回`Vue.options`。而对于组件构造函数，其`options`的解析还需要根据其父类的options做额外的处理。

### 3. mergeOptions
回到`mergeOptions`：
```js
// src/core/util/options.js
function mergeOptions (parent, child, vm) {
  if (typeof child === 'function') child = child.options

  // 对options.props、options.inject、options.directives做规范化处理
  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  const extendsFrom = child.extends
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm)
  }
  if (child.mixins) {
    for (let i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm)
    }
  }

  const options = {}
  for (let key in parent) mergeField(key)
  for (let key in child) {
    if (!hasOwn(parent, key)) mergeField(key)
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }

  return options
}
```

`mergeOptions`的主要作用是将`parent`、`child`合并成一个新的`options`并返回：
- 先递归调用`mergeOptions`将`child.extends`、`child.mixins`合并到`parent`上
- 遍历`parent`、`child`的属性名`key`，通过调用`strats`中记录的对应的合并策略`strats[key]`。

`strats`记录了各种`key`对应的合并策略，比如对于生命周期钩子`created`、`mounted`...，它们的合并策略是`mergeHook`：
```js
const strats = Object.create(null)
const LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
]

LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook
})

// 将父options上的钩子和子options上的钩子进行合并
function mergeHook (parentVal, childVal) {
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
  return res
    ? dedupeHooks(res)
    : res
}
```

在经过一些列的options合并完之后，`vm.$options`差不多长这样：

### 总结
这一小节分析了`Vue`初始化阶段的`options`的合并过程，合并方式有两种：
- 子组件初始化过程通过`initInternalComponent`
- 手动调用构造函数`Vue`是通过`mergeOptions`

前者比后者更快。

合并`optoins`的作用是将构造函数上的静态`options`与创建实例提供的`options`合并到所创建的实例的`$options`中。
