Vue.js的另一个核心思想就是组件化，接下来我们将分析Vue组件的原理。

同样的，Vue组件要渲染到页面中去，也需要经历将组件转为`vnode`、`vnode`转为DOM的过程，本节将分析如何将组件转换为对应的`vnode`。

如果还有印象，之前分析的用于创建`vnode`的`createElement`方法，在规范化`children`之后创建`vnode`时有这样一段逻辑：
```js
function _createElement (context, tag, data, children, normalizationType) {
  // 规范化children

  // 创建vnode
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    if (config.isReservedTag(tag)) {
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context)
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      vnode = new VNode(tag, data, children, undefined, undefined, context)
    }
  } else {
    // 组件vnode
    vnode = createComponent(tag, data, context, children)
  }
  return vnode
}
```

对于以如下方式实例化Vue：
```js
import Vue from 'vue'
import App from './App.vue'

var app = new Vue({
  el: '#app',
  render: h => h(App)
})
```

因为这里传入的是一个`App`对象：

![App](https://pic.downk.cc/item/5f57ac87160a154a67bb9b49.jpg)

所以`_createElement`内的逻辑会走到`createComponent(tag, data, context, children)`逻辑中去：
```js
// src/core/vdom/create-component.js
function createComponent (Ctor, data, context, children, tag) {
  // options._base为Vue方法
  const baseCtor = context.$options._base

  // 创建组件构造函数
  if (isObject(Ctor)) Ctor = baseCtor.extend(Ctor)

  // 异步组件
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)
    if (Ctor === undefined) return createAsyncPlaceholder(asyncFactory, data, context, children, tag)
  }

  data = data || {}

  // 安装组件钩子函数
  installComponentHooks(data)

  // 创建vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )
  return vnode
}
```
