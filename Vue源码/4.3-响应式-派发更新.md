在分析了响应式数据的依赖收集的过程后，接着来看依赖派发更新。再次回到`defineReactive`为响应式数据添加的`setter`：
```js
function defineReactive (obj, key, val, customSetter, shallow) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {},
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}
```

`setter`中有两个需要关注的地方：
- 一个是`child = !shallow && observe(newVal)`
- 另一个是`dep.notify()`，通知订阅者

当在Vue实例中对响应式数据进行了修改，就会触发`setter`，`dep.notify`的逻辑就是遍历`dep.subs`调用`Watcher`实例（订阅者）的`update`：
```js
class Dep {
  constructor () {
    this.id = uid++
    this.subs = []
  }
  notify () {
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

`Watcher`的`update`：
```js
class Watcher {
  constructor (vm, expOrFn, cb, options, isRenderWatcher) {}
  update () {
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
}
```

### queueWacther
`update`针对`watcher`的不同状态做了不同处理，`lazy`和`sync`会在后续分析，这里暂时只看`queueWatcher`：
```js
function queueWatcher (watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}
```

这里引入了**队列**的概念——并不是每次数据改变都会触发`watcher`（订阅者）的更新操作，Vue的设计是将这些`watcher`（订阅者）存储在一个队列`queue`中，并通过`has`对象保证同一个`Watcher`实例（订阅者）只被添加一次，然后在`nextTick`后通过`flushSchedulerQueue`执行它们：
```js
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow()
  flushing = true
  let watcher, id

  queue.sort((a, b) => a.id - b.id)

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
  }
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)
}
```

`flushSchedulerQueue`主要做了：
1. 对`queue`队列中的`watcher`按照其`id`做了从小到大的排序，为了确保以下几点：
   - 组件的更新是由父到子的：因为父组件的创建是先于子的，所以`watcher`的创建也是先父后子，因此需要其对应的回调的执行顺序也保持先父后子。
   - 用户的自定义`watcher`要优先于渲染`watcher`执行；因为用户自定义`watcher`是在渲染`watcher`之前创建的。
   - 如果一个组件在其父组件的`watcher`执行期间被销毁，那么它对应的`watcher`可以被跳过，所以父组件的`watcher`应该先执行。
  
2. 遍历`queue`队列中的`watcher`，执行`watcher.run()`。在这一步中，每一次对`watcher.run`进行调用都会对队列长度`queue.length`进行计算，因为`watcher.run()`执行时有可能会有新的`watcher`被添加，这样会再次回到`flushSchedulerQueue`：
    ```js
    function queueWatcher (watcher) {
      const id = watcher.id
      if (has[id] == null) {
        has[id] = true
        if (!flushing) {
          queue.push(watcher)
        } else {
          let i = queue.length - 1
          while (i > index && queue[i].id > watcher.id) {
            i--
          }
          queue.splice(i + 1, 0, watcher)
        }
      }
    }
    ```

    在这种情况下，`flushing`为`true`，后续的执行逻辑是在`queue`队列（存储的是`watcher`实例）中从后往前（前面已经说过队列中`watcher`按id从小到大排序）找第一个比当前待插入的`watcher`的id小的`watcher`的位置，将当前待插入的`watcher`插入`queue`队列的此位置上。

3. 状态恢复：
    ```js
    function resetSchedulerState () {
      index = queue.length = activatedChildren.length = 0
      has = {}
      if (process.env.NODE_ENV !== 'production') {
        circular = {}
      }
      waiting = flushing = false
    }
    ```

    将`watcher`队列清空，并将流程状态控制的相关变量恢复到初始值。


### watcher.run
```js
class Watcher {
  constructor () {}

  run () {
    if (this.active) {
      const value = this.get()
      if (value !== this.value || isObject(value) || this.deep) {
        const oldValue = this.value
        this.value = value

        this.cb.call(this.vm, value, oldValue)
      }
    }
  }
}
```

`watcher.run`的逻辑就是首先通过`watcher.get()`得到`wathcer`当前的值，如果满足：
- 新旧值不等
- 新值是对象类型
- deep模式

中任一个，则执行`watcher`的回调，注意回调函数执行时的参数`value`和`oldValue`，它们正是我们在添加自定义`watch`在回调函数的参数中拿到的新、旧值。

而在`watcher.get`执行时，`watcher.getter`会得到执行，即：
```js
updateComponent = () => {
  vm._update(vm._render(), hydrating)
}
```

这就是在修改Vue实例的响应式数据时，会重新触发实例的渲染的原因。

### 总结
在这里分析了Vue的响应式数据派发更新的过程——当数据变化时：
1. 响应式数据的`set`通知`dep.notify()`
2. 遍历`dep.subs`的`watcher`执行`watcher.update()`
3. `watcher.run`执行了`watcher.getter`
4. `vm._update(vm._render(), hydrating)`
   

`watcher.update()`又利用了队列做了进一步优化，在`nextTick`后执行所有`watcher.run()`，最后执行它们的回调函数，下一节我们来重点分析`nextTick`的实现。
