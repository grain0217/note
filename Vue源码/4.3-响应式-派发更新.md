在分析了响应式数据的依赖收集的过程后，接着来看依赖派发更新。我们知道，当对Vue实例的响应式数据进行修改时，就会触发对应的`setter`：
```js
function defineReactive (obj, key, val, customSetter, shallow) {
  const dep = new Dep()

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      
      // 新旧值作比较
      if (newVal === value || (newVal !== newVal && value !== value)) return
        
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }

      // 将新设置的值再次处理为响应式对象
      childOb = !shallow && observe(newVal)

      // 通知dep的所有订阅者watcher
      dep.notify()
    }
  })
}
```

这里会比较响应式数据新旧值是否相同，如果相同则不会派发更新；对于被重置后的响应式数据，需要再次将其处理为响应式的。最后是发布者`dep.notify()`通知它的所有订阅者`watcher`，回到`Dep.notify`：
```js
class Dep {
  //...
  notify () {
    // watcher列表
    const subs = this.subs.slice()

    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

`dep.notify`的逻辑就是遍历其`subs`中所维护的订阅者`watcher`，调用对应的`update`：
```js
class Watcher {
  // ...
  update () {
    if (this.lazy) {
      // 计算属性computed watcher
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
}
```

`update`的流程中根据`watcher`的不同类型（渲染/计算属性...）做了不同处理，这里暂时只讨论渲染`watcher`的`queueWatcher`。

### queueWatcher
要清楚的是，并不是所有响应式数据的改变触发的`watcher.update`都会被执行——Vue的设计是将这些需要更新操作的`watcher`先存储在一个队列中，然后在`nextTick`中`flushSchedulerQueue`它们：
```js
let waiting = false
let flushing = false

function queueWatcher (watcher) {
  const id = watcher.id
  // 某个响应式数据被改变多次，只需更新一次即可
  if (has[id] == null) {
    // 
    has[id] = true

    if (!flushing) {
      queue.push(watcher)
    } else {
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }

    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
```

这里通过`has`对象验证`watcher.id`保证同一个`watcher`只被添加一次。这样一来，如果一个`watcher`的`update`被触发了多次（这是很常见的场景，因为一个`wathcer`对应一个Vue实例，想象一个实例下的多个响应式数据被手动修改的话它们均会触发同一个`watcher.update`），`wathcher`只会被加入`queue`中一次，因为也只需要一次`update`即可。

```js
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  queue.sort((a, b) => a.id - b.id)

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) watcher.before()
    id = watcher.id
    // 在has中将watcher删除，否则下一次update时watcher不通过校验无法被加入到queue中
    has[id] = null
    watcher.run()
  }
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  // 重置
  resetSchedulerState()

  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)
}
```

`flushSchedulerQueue`主要做了以下几件事情：
##### 1. 对`queue`队列中的watcher按照其id从小到大排序
排序的操作是为了确保以下几点：
- **组件的更新是由父到子的**：因为父组件实例的创建是先于子的，所以`watcher`的创建也是先父后子，因此需要其对应的回调（`watcher.run`）的执行顺序也保持先父后子。
- 用户自定义的`watcher`要优先于渲染`watcher`触发——因为用户自定义`watcher`是在渲染`watcher`之前创建的。
- 如果一个组件在其父组件的`watcher`执行期间被销毁，那么它对应的`watcher`可以被跳过，所以父组件的`watcher`应该先执行。
  
##### 2. 遍历queue队列中的watcher，调用watcher.run()
`watcher.run`方法稍后分析，我们先来看`queue`的循环条件——对`queue`队列长度的计算是实时的，因为在`watcher.run()`执行时可能会有新的`watcher`被加入到`queue`中，这样当再次回到`flushSchedulerQueue`中时：
```js
function queueWatcher (watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
  }
}
```

在这种情况下，`flushing`为`true`，后续的执行逻辑是在`queue`队列中从后往前（前文已经说过队列中`watcher`是按id从小到大排序）找第一个比当前待插入的`watcher`的id小的`watcher`的位置，将待插入的`watcher`插入`queue`队列的此位置上。

##### 3. 状态恢复
这一步用于重置队列及异步更新流程的相关变量：
```js
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0
  has = {}
  waiting = flushing = false
}
```

将`queue`队列清空，并将`waiting`、`flushing`重置为`false`。

### watcher.run
这一步是派发更新的关键一环：
```js
class Watcher {
  // ...
  run () {
    if (this.active) {
      const value = this.get()
      if (value !== this.value || isObject(value) || this.deep) {
        const oldValue = this.value
        this.value = value

        this.cb.call(this.vm, value, oldValue)
      }
    }
  }
}
```

`watcher.run`的逻辑就是首先通过`watcher.get()`得到`wathcer`当前的值，如果满足：
- 新旧值不等
- 新值是对象类型
- deep模式

中任一个，则执行`watcher`的回调，注意回调函数执行时的参数`value`和`oldValue`，它们正是我们在添加自定义`watch`在回调函数的参数中拿到的新、旧值。

前文已经讨论过在`watcher.get`执行时，`watcher.getter`又会得到执行，即：
```js
updateComponent = () => {
  vm._update(vm._render(), hydrating)
}
```

这就是在修改Vue实例的响应式数据时，会重新触发实例的渲染的原因。

现在仔细回忆一下这个`updateComponent`，它是在实例挂载时作为`expOrfn`参数传入创建的渲染`watcher`中的，至此我们知道`updateComponent`方法执行的两个场景了：
- 一个是初次挂载实例`vm.$mount`时，创建vnode导致实例的响应式数据被访问时
- 另一个就是本节所讲的实例的响应式数据被修改时，响应式数据中的发布者`dep`通知订阅者`watcher`执行`watcher.run`

### 总结
在这里分析了Vue的响应式数据派发更新的过程——当数据变化时：
1. 响应式数据的`set`中的`dep`发布变化的通知
2. 遍历`dep.subs`的订阅者`watcher`执行`watcher.update()`
3. `watcher.run`又触发了`watcher.getter`
4. `vm._update(vm._render(), hydrating)`
   
需要`update`操作的`wathcer`被存入`queue`，等待在`nextTick`中被遍历唤起，下一节我们会重点分析`nextTick`的实现。
