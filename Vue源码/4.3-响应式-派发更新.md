在分析了响应式数据的依赖收集的过程后，接着来看依赖派发更新。再次回到`defineReactive`为响应式数据添加的`setter`：
```js
function defineReactive (obj, key, val, customSetter, shallow) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {},
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}
```

`setter`中有两个需要关注的地方：
- 一个是`child = !shallow && observe(newVal)`
- 另一个是`dep.notify()`，通知订阅者

当在Vue实例中对响应式数据进行了修改，就会触发`setter`，`dep.notify`的逻辑就是遍历`dep.subs`调用`Watcher`实例（订阅者）的`update`：
```js
class Dep {
  constructor () {
    this.id = uid++
    this.subs = []
  }
  notify () {
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

`Watcher`的`update`：
```js
class Watcher {
  constructor (vm, expOrFn, cb, options, isRenderWatcher) {}
  update () {
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
}
```

`update`针对`Watcher`实例的不同状态做了不同处理，`lazy`和`sync`会在后续分析，这里暂时只看`queueWatcher`：
```js
function queueWatcher (watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}
```

这里引入了**队列**的概念，这也是Vue在做派发更新的时候的一个优化的点，它并不会每次数据改变都触发`watcher`（订阅者）的回调，而是把这些`watcher`（订阅者）先添加到一个队列里，然后在`nextTick`后执行`flushSchedulerQueue`。
