 每个Vue实例从创建到销毁都要经过一系列过程——设置数据监听、编译模板、挂载实例到DOM并在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，通过对应的钩子函数开发者可以添加代码使得它们在Vue实例的不同阶段运行。

![Vue实例生命周期](https://pic.downk.cc/item/5faac3511cd1bbb86bd1b150.png)

在Vue.js的源码中，实例的生命周期钩子是通过`callHook`触发的：
```js
// src/core/instance/lifecycle
function callHook (vm, hook) {
  pushTarget()
  const handlers = vm.$options[hook]
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      handlers[i].call(vm)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

根据传入的参数生命周期钩子`hook`字符串，拿到对应实例的钩子`vm.$options[hook]`中记录的回调函数数组，遍历执行它，这就是`callhoook`函数的逻辑。

### 1. beforeCreate和created
`beforeCreate`、`created`钩子在初始化Vue实例时执行的`_init`方法中被触发：
```js
Vue.prototype._init = function (options) {
  // ...
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  callHook(vm, 'beforeCreate')
  initInjections(vm)
  initState(vm)
  initProvide(vm)
  callHook(vm, 'created')
  // ...
}
```

`initState`用于初始化实例的`props`、`data`、`methods`、`watch`、`computed`等属性，`beforeCreate`钩子在`initState`方法之前触发，因此在`beforeCreate`钩子中注册的回调无法访问实例的这些属性、方法，而`created`的可以。

这两个钩子的触发又是在实例挂载`$mount`方法执行之前，所以它们注册的回调也无法访问DOM。

### 2. beforeMount和mounted
`beforeMount`和`mounted`钩子在实例挂载过程中触发：
```js
Vue.prototype.$mount = function (el) {
  return mountComponent(this, el)
}

function mountComponent (vm, el) {
  vm.$el = el

  // 触发beforeMount钩子
  callHook(vm, 'beforeMount')

  let updateComponent
  if (process.env.NODE_ENV !== 'production') {
    // updateComponent = 
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true)

  if (vm.$vnode == null) {
    vm._isMounted = true
    // 触发mounted钩子
    callHook(vm, 'mounted')
  }

  return vm
}
```

在`vm._render`渲染生成vnode之前，`beforeMount`钩子触发；在`vm._update`将vnode渲染为真实DOM之后，`mounted`钩子触发。

<!-- 组件实例的vm.$vnode是？ -->
需要注意的是上面所提到的`mounted`钩子触发的逻辑——`vm.$vnode == null`，这意味着这里触发的是通过手动调用`Vue`创建的实例的`mounted`钩子。而对于组件实例，在组件patch的最后一步`invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)`（2.3小节）：
```js
function invokeInsertHook (vnode, queue, initial) {
  if (isTrue(initial) && isDef(vnode.parent)) {
    vnode.parent.data.pendingInsert = queue
  } else {
    for (let i = 0; i < queue.length; ++i) {
      queue[i].data.hook.insert(queue[i])
    }
  }
}
```

这里会将`insertedVnodeQueue`中保存的钩子函数依次执行，组件vnode的`insert`钩子函数是在创建组件vnode时通过`installComponentHooks`时安装在`vnode.data.hook`上的：
```js
const componentVNodeHooks = {
  insert (vnode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
  },
}
```

可以看到子组件是在`insert`钩子函数执行时触发实例的`mounted`钩子的。`insertedVnodeQueue`的添加顺序是先子后父，所以对于同步渲染的子组件，`mounted`钩子函数的执行顺序也是先子后父。

### 3. beforeUpdate和Updated

### 4. beforeDestroy和destroyed

### 总结
