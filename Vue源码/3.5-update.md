上节已经提到，`_update`方法用于将`VNode`渲染成真实的`DOM`，该方法有两个调用时机——一个首次渲染，一个是数据更新。本节仅分析首次渲染时`update`方法的执行，数据更新时的逻辑在后续响应式原理中分析。

```js
/*
* src/core/instance/lifecycle.js
*/

Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used.
  if (!prevVnode) {
    // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
  // updated hook is called by the scheduler to ensure that children are
  // updated in a parent's updated hook.
}

```

可以看到，
```js
vm.$el = vm.__patch__()
```
`_update`方法是通过调用`vm.__patch__`生成/更新真实`DOM`，然后将它赋值给`vm.$el`。

`createPatchFunction`方法内部定义了很多辅助方法，最终返回了一个`patch`方法，这个方法正是`vm._update`方法内调用的`vm.__patch__`方法。

```js
// 返回patch函数，执行这个函数可以实际更新dom
function patch (oldVnode, vnode, hydrating, removeOnly) {
  // 如果新的vnode不存在，老的vnode存在，那么销毁老的vnode,然后返回undefined
  // 之后的vm.$el = undefined那么页面中这个元素就会被销毁
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }

  let isInitialPatch = false
  const insertedVnodeQueue = []

  // 如果oldVnode未定义说明是创建
  if (isUndef(oldVnode)) {
    // 如果是新创建的组件 的话
    // empty mount (likely as component), create new root element
    isInitialPatch = true
    // 创建元素
    createElm(vnode, insertedVnodeQueue)
  } else {
    // 根实例会走else，因为vm.$el不为空，也就是第一次渲染会进else

    // 是否是真实的dom
    const isRealElement = isDef(oldVnode.nodeType)
    if (!isRealElement && sameVnode(oldVnode, vnode)) {
      // patch existing root node
      // diff算法，新旧节点比对
      patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
    } else {
      // 创建根组件会走这个逻辑，因为首次渲染调用vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
      // 传入的是一个真实根节点
      // 是真实的dom
      if (isRealElement) {
        /* 服务端渲染处理代码省略 */
        
        // either not server-rendered, or hydration failed.
        // create an empty node and replace it
        // 创建一个空的节点
        oldVnode = emptyNodeAt(oldVnode)
      }

      // replacing existing element
      const oldElm = oldVnode.elm
      const parentElm = nodeOps.parentNode(oldElm)

      // 创建一个新的dom节点
      // create new node
      createElm(
        vnode,
        insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
      )
      /* 非重要代码省略 */
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
  return vnode.elm
}
```